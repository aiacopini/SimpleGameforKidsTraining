<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Goku's Candy Cloud Rider</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      background: #000;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: monospace;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
// === CORE ENGINE ===

// ============================================================
// SECTION 1: CONSTANTS & CONFIG
// ============================================================

const CANVAS_W = 960, CANVAS_H = 540;
const GRAVITY = 0.3;
const SCROLL_SPEED = 50;

// Game states enum
const STATE = {
  MENU: 0,
  LEVEL_INTRO: 1,
  PLAYING: 2,
  BOSS_FIGHT: 3,
  LEVEL_COMPLETE: 4,
  GAME_OVER: 5,
  VICTORY: 6,
  PAUSED: 7
};

// Difficulty settings
const DIFFICULTY = {
  EASY: 0,
  NORMAL: 1,
  HARD: 2
};
var currentDifficulty = DIFFICULTY.NORMAL;
var difficultyMultipliers = [
  { enemyHp: 0.6, enemyDmg: 0.5, enemySpeed: 0.8, playerHp: 200, playerKiRegen: 15, label: 'EASY' },
  { enemyHp: 1.0, enemyDmg: 1.0, enemySpeed: 1.0, playerHp: 150, playerKiRegen: 12, label: 'NORMAL' },
  { enemyHp: 1.4, enemyDmg: 1.5, enemySpeed: 1.2, playerHp: 120, playerKiRegen: 10, label: 'HARD' }
];

// Screen transition state
var screenTransition = {
  active: false,
  fadeIn: false,
  alpha: 0,
  duration: 0.4,
  elapsed: 0,
  callback: null
};

// Tutorial state
var showTutorial = !localStorage.getItem('gokuTutorialSeen');
var tutorialStep = 0;
var tutorialTimer = 0;

// Menu selection state
var menuSelection = 0; // 0 = start, 1 = difficulty

// Colors config - Candy Land theme
const COLORS = {
  // Goku (brighter, more saturated)
  gokuGiOrange: '#FF7722',
  gokuGiOrangeDark: '#DD5500',
  gokuGiOrangeLight: '#FFAA55',
  gokuBelt: '#4466DD',
  gokuBeltLight: '#6688FF',
  gokuSkin: '#FFDDBB',
  gokuSkinShadow: '#EEBB88',
  gokuHairBlack: '#222222',
  gokuHairHighlight: '#444444',
  gokuBoots: '#4466DD',
  gokuBootsLight: '#6688FF',
  gokuWristband: '#4466DD',
  gokuEyeWhite: '#FFFFFF',
  gokuEyePupil: '#222222',

  // Nimbus Cloud (brighter golden)
  cloudYellow: '#FFEE66',
  cloudYellowLight: '#FFF8AA',
  cloudYellowDark: '#EECC33',
  cloudTrail: '#FFFADD',

  // Candy Attacks (replaces Ki/Energy)
  kiBlue: '#CC8844',       // cookie brown
  kiBlueBright: '#DDAA66',
  kiBlueCore: '#FFFFFF',
  kiYellow: '#FFEE44',
  kiYellowBright: '#FFFF88',
  kamehamehaBlue: '#FF66AA',    // rainbow candy pink
  kamehamehaCoreWhite: '#FFFFFF',
  spiritBombWhite: '#FFFFFF',
  spiritBombBlue: '#FF88CC',    // lollipop pink
  spiritBombGlow: '#FFAADD',

  // Aura (candy sparkle)
  auraSuperYellow: '#FFD700',
  auraChargeBlue: '#FF88BB',   // pink candy charge
  auraWhite: '#FFFFFF',

  // Enemies - Level 1 (Candy Field creatures)
  rrSoldierGreen: '#CC8844',   // gingerbread brown
  rrSoldierHelmet: '#FFFFFF',  // white icing
  rrRobotGray: '#FFAA77',     // donut glaze
  rrRobotDark: '#DD7744',     // donut body
  rrRobotRed: '#FF66AA',      // pink sprinkle
  rrNinjaPurple: '#FF4466',   // jellybean red
  rrNinjaDark: '#DD2244',

  // Enemies - Level 2 (Chocolate Kingdom creatures)
  friezaSoldierPurple: '#FFCC44',  // candy corn yellow
  friezaArmorWhite: '#FFFFFF',     // candy corn white tip
  friezaArmorBrown: '#FF8822',     // candy corn orange
  dodoriaPink: '#884422',          // chocolate truffle
  dodoriaPinkDark: '#663311',      // dark chocolate
  ginyuPurple: '#FF44AA',         // lollipop pink
  ginyuBodyBlack: '#44DD44',      // lollipop green

  // Enemies - Level 3 (Sugar Crystal creatures)
  cellGreen: '#44DD66',           // sour gummy green
  cellGreenDark: '#22AA44',
  cellSpots: '#FFEE44',           // gummy highlight
  darkCloneShadow: '#886644',     // shadow cookie brown
  darkCloneGlow: '#FFAA44',       // golden glow
  buuPink: '#FFAACC',             // bubblegum pink
  buuPinkDark: '#FF88AA',

  // Bosses (candy themed)
  bossLevel1Core: '#FF4488',      // cherry on cupcake
  bossLevel1Metal: '#FFD4E8',     // pink frosting
  bossLevel1MetalDark: '#FFBBCC', // cupcake wrapper
  bossLevel2Purple: '#88DD44',    // candy dragon green
  bossLevel2PurpleDark: '#66AA22',
  bossLevel2Tail: '#FF4444',      // licorice red
  bossLevel3Dark: '#FFFFEE',      // cake white
  bossLevel3Eyes: '#FF4488',      // cherry eyes
  bossLevel3Glow: '#FFD700',      // golden candle glow

  // Backgrounds - Level 1 (Candy Fields)
  skyBlue: '#FFD4E8',            // pink candy sky
  skyBlueDark: '#FFBBDD',
  mountainGreen: '#88DD88',      // gumdrop green
  mountainGreenLight: '#AAFFAA',
  hillGreen: '#FF88AA',          // candy cane pink hills
  groundBrown: '#DDAA77',        // cookie ground
  buildingGray: '#FFCC88',       // wafer buildings

  // Backgrounds - Level 2 (Chocolate Kingdom)
  namekSkyGreen: '#FFCC88',      // warm golden sky
  namekSkyGreenDark: '#EEAA66',
  namekGroundBlue: '#664422',    // chocolate ground
  namekGroundTeal: '#553311',
  namekRockBrown: '#AA7744',     // wafer towers
  namekWater: '#884422',         // chocolate river

  // Backgrounds - Level 3 (Sugar Crystal Realm)
  voidWhite: '#EEEEFF',
  darkRealmBg: '#DDEEFF',        // light crystal blue
  darkRealmPurple: '#CCDDFF',
  nebulaBlue: '#AACCFF',         // blue crystal
  nebulaPink: '#FFAADD',         // pink crystal
  starWhite: '#FFFFFF',
  starYellow: '#FFD700',

  // UI / HUD (candy themed)
  hpGreen: '#FF6688',            // cookie jar red
  hpYellow: '#FFAA44',
  hpRed: '#FF2244',
  hpBarBg: '#FFE4CC',
  hpBarBorder: '#FF88AA',
  kiBarBlue: '#FF88CC',          // candy meter pink
  kiBarGlow: '#FFAADD',
  kiBarBg: '#FFE4F0',
  kiBarBorder: '#FF88AA',
  scoreGold: '#FFD700',
  uiWhite: '#FFFFFF',
  uiBlack: '#442200',
  uiShadow: '#884422',
  bossHpRed: '#FF4466',
  bossHpBg: '#FFD4DD',

  // Effects (candy pops & sprinkles)
  explosionOrange: '#FFAA44',    // caramel pop
  explosionYellow: '#FFEE66',    // lemon drop
  explosionRed: '#FF66AA',       // strawberry burst
  explosionWhite: '#FFFFFF',
  hitWhite: '#FFFFFF',
  flashWhite: '#FFFFFF',
  flashRed: '#FF88AA66',

  // Powerups (candy items)
  senzuGreen: '#FF88AA',         // cupcake pink
  senzuGreenLight: '#FFAACC',
  kiOrbBlue: '#FF4444',          // candy cane red
  kiOrbGlow: '#FF8888',
  dragonBallOrange: '#FFD700',   // golden cookie
  dragonBallStar: '#FFAA00',
  speedBoostYellow: '#FFAADD',   // cotton candy pink
  speedBoostGlow: '#FFCCEE'
};

// ============================================================
// SECTION 2: INPUT HANDLER
// ============================================================

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  z: false,    // ki blast
  x: false,    // melee
  c: false,    // kamehameha charge
  v: false     // spirit bomb
};

// Track just-pressed for single-fire actions
const keysJustPressed = {
  z: false,
  x: false,
  v: false
};

const keysPrevious = {
  z: false,
  x: false,
  v: false
};

function updateInputJustPressed() {
  keysJustPressed.z = keys.z && !keysPrevious.z;
  keysJustPressed.x = keys.x && !keysPrevious.x;
  keysJustPressed.v = keys.v && !keysPrevious.v;
  keysPrevious.z = keys.z;
  keysPrevious.x = keys.x;
  keysPrevious.v = keys.v;
}

window.addEventListener('keydown', function(e) {
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
    keys[e.key] = true;
    e.preventDefault();
  }
  if (e.key === 'z' || e.key === 'Z') { keys.z = true; e.preventDefault(); }
  if (e.key === 'x' || e.key === 'X') { keys.x = true; e.preventDefault(); }
  if (e.key === 'c' || e.key === 'C') { keys.c = true; e.preventDefault(); }
  if (e.key === 'v' || e.key === 'V') { keys.v = true; e.preventDefault(); }
  // Pause toggle
  if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
    if (gameState === STATE.PLAYING || gameState === STATE.BOSS_FIGHT) {
      pausedFromState = gameState;
      gameState = STATE.PAUSED;
      e.preventDefault();
    } else if (gameState === STATE.PAUSED) {
      gameState = pausedFromState;
      e.preventDefault();
    }
  }
});

window.addEventListener('keyup', function(e) {
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
    keys[e.key] = false;
  }
  if (e.key === 'z' || e.key === 'Z') { keys.z = false; }
  if (e.key === 'x' || e.key === 'X') { keys.x = false; }
  if (e.key === 'c' || e.key === 'C') { keys.c = false; }
  if (e.key === 'v' || e.key === 'V') { keys.v = false; }
});

// Touch control support
const touchButtons = {};
let touchControlsVisible = false;

function initTouchControls(canvas) {
  const btnSize = 68;
  const margin = 12;
  const bottomY = CANVAS_H - btnSize - margin;
  const dpadCenterX = margin + btnSize + 8;
  const dpadCenterY = bottomY - btnSize - 8;
  const gap = 4;

  // D-pad buttons (left side) - larger with arrow symbols
  touchButtons.ArrowUp    = { x: dpadCenterX - btnSize / 2, y: dpadCenterY - btnSize - gap, w: btnSize, h: btnSize, label: '\u25B2', active: false, color: '#FFFFFF', isDirection: true };
  touchButtons.ArrowDown  = { x: dpadCenterX - btnSize / 2, y: dpadCenterY + btnSize + gap, w: btnSize, h: btnSize, label: '\u25BC', active: false, color: '#FFFFFF', isDirection: true };
  touchButtons.ArrowLeft  = { x: dpadCenterX - btnSize - btnSize / 2 - gap, y: dpadCenterY, w: btnSize, h: btnSize, label: '\u25C0', active: false, color: '#FFFFFF', isDirection: true };
  touchButtons.ArrowRight = { x: dpadCenterX + btnSize / 2 + gap, y: dpadCenterY, w: btnSize, h: btnSize, label: '\u25B6', active: false, color: '#FFFFFF', isDirection: true };

  // Action buttons (right side) - larger, clearer labels, better colors
  const actionX = CANVAS_W - margin - btnSize * 2 - 18;
  touchButtons.z = { x: actionX + btnSize + 18, y: bottomY - btnSize - 8, w: btnSize, h: btnSize, label: 'SHOOT', active: false, color: '#FFCC44', emoji: '\uD83C\uDF6A' };
  touchButtons.x = { x: actionX, y: bottomY, w: btnSize, h: btnSize, label: 'HIT', active: false, color: '#FF8844', emoji: '\uD83D\uDCA5' };
  touchButtons.c = { x: actionX + btnSize + 18, y: bottomY, w: btnSize, h: btnSize, label: 'BEAM', active: false, color: '#FF66BB', emoji: '\uD83C\uDF08' };
  touchButtons.v = { x: actionX, y: bottomY - btnSize - 8, w: btnSize, h: btnSize, label: 'SUPER', active: false, color: '#AA88FF', emoji: '\u2B50' };

  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

  touchControlsVisible = true;
}

function getTouchPos(canvas, touch) {
  var rect = canvas.getBoundingClientRect();
  var scaleX = CANVAS_W / rect.width;
  var scaleY = CANVAS_H / rect.height;
  return {
    x: (touch.clientX - rect.left) * scaleX,
    y: (touch.clientY - rect.top) * scaleY
  };
}

function handleTouchStart(e) {
  e.preventDefault();
  initAudioContext();
  var canvas = e.target;
  for (var i = 0; i < e.changedTouches.length; i++) {
    var pos = getTouchPos(canvas, e.changedTouches[i]);
    for (var key in touchButtons) {
      var btn = touchButtons[key];
      if (pos.x >= btn.x && pos.x <= btn.x + btn.w && pos.y >= btn.y && pos.y <= btn.y + btn.h) {
        btn.active = true;
        btn.touchId = e.changedTouches[i].identifier;
        keys[key] = true;
      }
    }
  }
}

function handleTouchMove(e) {
  e.preventDefault();
  var canvas = e.target;
  // Reset all touch buttons first
  for (var key in touchButtons) {
    var btn = touchButtons[key];
    var stillTouched = false;
    for (var i = 0; i < e.touches.length; i++) {
      var pos = getTouchPos(canvas, e.touches[i]);
      if (pos.x >= btn.x && pos.x <= btn.x + btn.w && pos.y >= btn.y && pos.y <= btn.y + btn.h) {
        stillTouched = true;
        break;
      }
    }
    if (!stillTouched && btn.active) {
      btn.active = false;
      keys[key] = false;
    } else if (stillTouched && !btn.active) {
      btn.active = true;
      keys[key] = true;
    }
  }
}

function handleTouchEnd(e) {
  e.preventDefault();
  for (var i = 0; i < e.changedTouches.length; i++) {
    var id = e.changedTouches[i].identifier;
    for (var key in touchButtons) {
      var btn = touchButtons[key];
      if (btn.touchId === id) {
        btn.active = false;
        keys[key] = false;
      }
    }
  }
}

function drawTouchControls(ctx) {
  if (!touchControlsVisible) return;
  ctx.save();
  for (var key in touchButtons) {
    var btn = touchButtons[key];
    var cx = btn.x + btn.w / 2;
    var cy = btn.y + btn.h / 2;
    var r = btn.w / 2;

    if (btn.isDirection) {
      // D-pad: semi-transparent white circles with arrow
      ctx.globalAlpha = btn.active ? 0.55 : 0.2;
      ctx.fillStyle = '#FFFFFF';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
      // Border
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
      // Arrow symbol
      ctx.globalAlpha = btn.active ? 1.0 : 0.5;
      ctx.fillStyle = '#333333';
      ctx.font = 'bold 22px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(btn.label, cx, cy + 1);
    } else {
      // Action buttons: colored circles with glow when active
      if (btn.active) {
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = btn.color;
        ctx.beginPath(); ctx.arc(cx, cy, r + 6, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = btn.active ? 0.7 : 0.35;
      // Gradient fill
      var bGrad = ctx.createRadialGradient(cx - r * 0.2, cy - r * 0.2, 0, cx, cy, r);
      bGrad.addColorStop(0, '#FFFFFF');
      bGrad.addColorStop(0.4, btn.color);
      bGrad.addColorStop(1, btn.color);
      ctx.fillStyle = bGrad;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
      // Border
      ctx.strokeStyle = btn.active ? '#FFFFFF' : 'rgba(255,255,255,0.5)';
      ctx.lineWidth = btn.active ? 3 : 2;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
      // Label text
      ctx.globalAlpha = btn.active ? 1.0 : 0.7;
      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(btn.label, cx, cy + 2);
    }
  }
  ctx.restore();
}

// ============================================================
// SECTION 3: SOUND SYSTEM (Web Audio API)
// ============================================================

var audioCtx = null;
var audioInitialized = false;
var masterGainNode = null;

function initAudioContext() {
  if (audioInitialized) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGainNode = audioCtx.createGain();
    masterGainNode.gain.value = 0.3;
    masterGainNode.connect(audioCtx.destination);
    audioInitialized = true;
  } catch (e) {
    // Web Audio API not supported
  }
}

// Ensure audio context is initialized on first user interaction
window.addEventListener('keydown', function initOnInput() {
  initAudioContext();
  window.removeEventListener('keydown', initOnInput);
}, { once: false });
window.addEventListener('click', function initOnClick() {
  initAudioContext();
  window.removeEventListener('click', initOnClick);
}, { once: false });

function playSound(name) {
  if (!audioCtx || !audioInitialized) return;
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }

  var now = audioCtx.currentTime;

  switch (name) {

    case 'kiBlast': {
      // Short energy zap - two oscillators with fast frequency sweep
      var osc1 = audioCtx.createOscillator();
      var osc2 = audioCtx.createOscillator();
      var gain = audioCtx.createGain();
      osc1.type = 'sine';
      osc1.frequency.setValueAtTime(800, now);
      osc1.frequency.exponentialRampToValueAtTime(600, now + 0.1);
      osc2.type = 'triangle';
      osc2.frequency.setValueAtTime(800, now);
      osc2.frequency.exponentialRampToValueAtTime(200, now + 0.12);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc1.connect(gain);
      osc2.connect(gain);
      gain.connect(masterGainNode);
      osc1.start(now);
      osc2.start(now);
      osc1.stop(now + 0.2);
      osc2.stop(now + 0.2);
      break;
    }

    case 'kamehameha': {
      // Rising charge beam - long sustained oscillator with rising pitch
      var osc1 = audioCtx.createOscillator();
      var osc2 = audioCtx.createOscillator();
      var osc3 = audioCtx.createOscillator();
      var gain = audioCtx.createGain();
      var filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(400, now);
      filter.frequency.linearRampToValueAtTime(4000, now + 0.8);
      filter.frequency.linearRampToValueAtTime(2000, now + 1.5);
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(100, now);
      osc1.frequency.linearRampToValueAtTime(400, now + 0.6);
      osc1.frequency.linearRampToValueAtTime(350, now + 1.5);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(150, now);
      osc2.frequency.linearRampToValueAtTime(450, now + 0.6);
      osc2.frequency.linearRampToValueAtTime(400, now + 1.5);
      osc3.type = 'sine';
      osc3.frequency.setValueAtTime(50, now);
      osc3.frequency.linearRampToValueAtTime(200, now + 0.6);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.linearRampToValueAtTime(0.3, now + 0.5);
      gain.gain.setValueAtTime(0.3, now + 1.0);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
      osc1.connect(filter);
      osc2.connect(filter);
      osc3.connect(filter);
      filter.connect(gain);
      gain.connect(masterGainNode);
      osc1.start(now);
      osc2.start(now);
      osc3.start(now);
      osc1.stop(now + 1.6);
      osc2.stop(now + 1.6);
      osc3.stop(now + 1.6);
      break;
    }

    case 'melee': {
      // Impact thud - noise burst with low frequency punch
      var bufferSize = audioCtx.sampleRate * 0.1;
      var buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      var data = buffer.getChannelData(0);
      for (var i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
      }
      var noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      var noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.3, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      var noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.setValueAtTime(600, now);
      noiseFilter.frequency.exponentialRampToValueAtTime(100, now + 0.1);
      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGainNode);

      var osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(40, now + 0.12);
      var oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.4, now);
      oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.connect(oscGain);
      oscGain.connect(masterGainNode);
      noise.start(now);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    }

    case 'spiritBomb': {
      // Epic rising tone - multiple harmonics building up
      var duration = 2.5;
      for (var h = 0; h < 5; h++) {
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = (h % 2 === 0) ? 'sine' : 'triangle';
        var baseFreq = 80 + h * 60;
        osc.frequency.setValueAtTime(baseFreq, now);
        osc.frequency.linearRampToValueAtTime(baseFreq * 3, now + duration * 0.7);
        osc.frequency.linearRampToValueAtTime(baseFreq * 4, now + duration);
        var delay = h * 0.15;
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.linearRampToValueAtTime(0.001, now + delay);
        gain.gain.linearRampToValueAtTime(0.12, now + delay + duration * 0.4);
        gain.gain.linearRampToValueAtTime(0.2, now + duration * 0.8);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(now);
        osc.stop(now + duration + 0.1);
      }
      // Add rumble
      var rumbleOsc = audioCtx.createOscillator();
      var rumbleGain = audioCtx.createGain();
      rumbleOsc.type = 'sine';
      rumbleOsc.frequency.setValueAtTime(30, now);
      rumbleOsc.frequency.linearRampToValueAtTime(60, now + duration);
      rumbleGain.gain.setValueAtTime(0.15, now);
      rumbleGain.gain.linearRampToValueAtTime(0.3, now + duration * 0.8);
      rumbleGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      rumbleOsc.connect(rumbleGain);
      rumbleGain.connect(masterGainNode);
      rumbleOsc.start(now);
      rumbleOsc.stop(now + duration + 0.1);
      break;
    }

    case 'explosion': {
      // Boom - filtered noise with descending frequency envelope
      var bufferSize = audioCtx.sampleRate * 0.5;
      var buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      var data = buffer.getChannelData(0);
      for (var i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1);
      }
      var noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      var filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1500, now);
      filter.frequency.exponentialRampToValueAtTime(100, now + 0.4);
      var gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGainNode);

      // Low punch
      var osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(80, now);
      osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
      var oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.3, now);
      oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.connect(oscGain);
      oscGain.connect(masterGainNode);
      noise.start(now);
      osc.start(now);
      osc.stop(now + 0.5);
      break;
    }

    case 'powerup': {
      // Cheerful chime - ascending arpeggiated notes
      var notes = [523, 659, 784, 1047, 1319]; // C5 E5 G5 C6 E6
      for (var i = 0; i < notes.length; i++) {
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(notes[i], now + i * 0.07);
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.linearRampToValueAtTime(0.001, now + i * 0.07);
        gain.gain.linearRampToValueAtTime(0.15, now + i * 0.07 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.07 + 0.25);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(now + i * 0.07);
        osc.stop(now + i * 0.07 + 0.3);
      }
      break;
    }

    case 'hit': {
      // Damage taken - quick descending burst with noise
      var osc = audioCtx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
      var gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.connect(gain);
      gain.connect(masterGainNode);
      // Noise component
      var bufferSize = audioCtx.sampleRate * 0.12;
      var buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      var data = buffer.getChannelData(0);
      for (var i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
      }
      var noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      var noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.2, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      var noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = 'bandpass';
      noiseFilter.frequency.setValueAtTime(1000, now);
      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGainNode);
      osc.start(now);
      noise.start(now);
      osc.stop(now + 0.25);
      break;
    }

    case 'bossIntro': {
      // Dramatic rumble - low oscillators with rising intensity
      var duration = 2.0;
      var osc1 = audioCtx.createOscillator();
      var osc2 = audioCtx.createOscillator();
      var osc3 = audioCtx.createOscillator();
      osc1.type = 'sine';
      osc1.frequency.setValueAtTime(35, now);
      osc1.frequency.linearRampToValueAtTime(50, now + duration);
      osc2.type = 'sawtooth';
      osc2.frequency.setValueAtTime(70, now);
      osc2.frequency.linearRampToValueAtTime(90, now + duration * 0.7);
      osc2.frequency.linearRampToValueAtTime(55, now + duration);
      osc3.type = 'triangle';
      osc3.frequency.setValueAtTime(45, now);
      osc3.frequency.linearRampToValueAtTime(80, now + duration * 0.5);
      osc3.frequency.linearRampToValueAtTime(40, now + duration);
      var gain1 = audioCtx.createGain();
      gain1.gain.setValueAtTime(0.05, now);
      gain1.gain.linearRampToValueAtTime(0.35, now + duration * 0.6);
      gain1.gain.linearRampToValueAtTime(0.25, now + duration * 0.8);
      gain1.gain.exponentialRampToValueAtTime(0.001, now + duration);
      var gain2 = audioCtx.createGain();
      gain2.gain.setValueAtTime(0.02, now);
      gain2.gain.linearRampToValueAtTime(0.15, now + duration * 0.5);
      gain2.gain.exponentialRampToValueAtTime(0.001, now + duration);
      var gain3 = audioCtx.createGain();
      gain3.gain.setValueAtTime(0.01, now);
      gain3.gain.linearRampToValueAtTime(0.1, now + duration * 0.5);
      gain3.gain.exponentialRampToValueAtTime(0.001, now + duration);
      var filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(200, now);
      filter.frequency.linearRampToValueAtTime(800, now + duration * 0.6);
      filter.frequency.linearRampToValueAtTime(200, now + duration);
      osc1.connect(gain1);
      osc2.connect(gain2);
      osc3.connect(gain3);
      gain1.connect(filter);
      gain2.connect(filter);
      gain3.connect(filter);
      filter.connect(masterGainNode);
      osc1.start(now); osc2.start(now); osc3.start(now);
      osc1.stop(now + duration + 0.1);
      osc2.stop(now + duration + 0.1);
      osc3.stop(now + duration + 0.1);

      // Noise rumble
      var bufferSize = audioCtx.sampleRate * duration;
      var buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      var data = buffer.getChannelData(0);
      for (var i = 0; i < bufferSize; i++) {
        var t = i / bufferSize;
        var envelope = Math.sin(t * Math.PI) * 0.3;
        data[i] = (Math.random() * 2 - 1) * envelope;
      }
      var noiseSrc = audioCtx.createBufferSource();
      noiseSrc.buffer = buffer;
      var nFilter = audioCtx.createBiquadFilter();
      nFilter.type = 'lowpass';
      nFilter.frequency.setValueAtTime(150, now);
      nFilter.frequency.linearRampToValueAtTime(400, now + duration * 0.5);
      nFilter.frequency.linearRampToValueAtTime(100, now + duration);
      var nGain = audioCtx.createGain();
      nGain.gain.setValueAtTime(0.15, now);
      noiseSrc.connect(nFilter);
      nFilter.connect(nGain);
      nGain.connect(masterGainNode);
      noiseSrc.start(now);
      break;
    }

    case 'levelComplete': {
      // Victory fanfare - ascending triumphant melody
      var melody = [
        { f: 523, t: 0.0,  d: 0.15 }, // C5
        { f: 587, t: 0.12, d: 0.15 }, // D5
        { f: 659, t: 0.24, d: 0.15 }, // E5
        { f: 784, t: 0.36, d: 0.25 }, // G5
        { f: 880, t: 0.55, d: 0.15 }, // A5
        { f: 784, t: 0.67, d: 0.15 }, // G5
        { f: 1047, t: 0.82, d: 0.5  }, // C6 (sustained)
      ];
      // Harmony
      var harmony = [
        { f: 330, t: 0.0,  d: 0.4 },  // E4
        { f: 392, t: 0.36, d: 0.4 },  // G4
        { f: 523, t: 0.82, d: 0.5 },  // C5
      ];
      for (var i = 0; i < melody.length; i++) {
        var n = melody[i];
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(n.f, now + n.t);
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.linearRampToValueAtTime(0.001, now + n.t);
        gain.gain.linearRampToValueAtTime(0.18, now + n.t + 0.01);
        gain.gain.setValueAtTime(0.18, now + n.t + n.d * 0.6);
        gain.gain.exponentialRampToValueAtTime(0.001, now + n.t + n.d);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(now + n.t);
        osc.stop(now + n.t + n.d + 0.05);
      }
      for (var i = 0; i < harmony.length; i++) {
        var n = harmony[i];
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(n.f, now + n.t);
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.linearRampToValueAtTime(0.001, now + n.t);
        gain.gain.linearRampToValueAtTime(0.1, now + n.t + 0.02);
        gain.gain.setValueAtTime(0.1, now + n.t + n.d * 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, now + n.t + n.d);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(now + n.t);
        osc.stop(now + n.t + n.d + 0.05);
      }
      break;
    }

    case 'gameOver': {
      // Sad descending tone - minor key descending melody
      var notes = [
        { f: 523, t: 0.0,  d: 0.35 }, // C5
        { f: 466, t: 0.3,  d: 0.35 }, // Bb4
        { f: 415, t: 0.6,  d: 0.35 }, // Ab4
        { f: 349, t: 0.9,  d: 0.7 },  // F4 (sustained)
      ];
      for (var i = 0; i < notes.length; i++) {
        var n = notes[i];
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(n.f, now + n.t);
        // Add slight vibrato on final note
        if (i === notes.length - 1) {
          var lfo = audioCtx.createOscillator();
          var lfoGain = audioCtx.createGain();
          lfo.frequency.value = 5;
          lfoGain.gain.value = 4;
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);
          lfo.start(now + n.t);
          lfo.stop(now + n.t + n.d + 0.1);
        }
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.linearRampToValueAtTime(0.001, now + n.t);
        gain.gain.linearRampToValueAtTime(0.2, now + n.t + 0.02);
        gain.gain.setValueAtTime(0.2, now + n.t + n.d * 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, now + n.t + n.d);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(now + n.t);
        osc.stop(now + n.t + n.d + 0.15);
      }
      // Low drone
      var drone = audioCtx.createOscillator();
      var droneGain = audioCtx.createGain();
      drone.type = 'sine';
      drone.frequency.setValueAtTime(65, now);
      drone.frequency.linearRampToValueAtTime(55, now + 1.6);
      droneGain.gain.setValueAtTime(0.1, now);
      droneGain.gain.linearRampToValueAtTime(0.15, now + 0.5);
      droneGain.gain.exponentialRampToValueAtTime(0.001, now + 1.6);
      drone.connect(droneGain);
      droneGain.connect(masterGainNode);
      drone.start(now);
      drone.stop(now + 1.7);
      break;
    }
  }
}

// ============================================================
// SECTION 4: PARTICLE SYSTEM
// ============================================================

class Particle {
  constructor(x, y, vx, vy, life, color, size) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.life = life;
    this.maxLife = life;
    this.color = color;
    this.size = size;
    this.initialSize = size;
    this.alpha = 1.0;
    this.gravity = 0;
    this.friction = 1.0;
    this.shrink = true;
    this.fadeOut = true;
    this.glow = false;
    this.glowSize = 0;
    this.shape = 'square'; // 'square', 'circle', 'diamond'
  }

  update(dt) {
    this.life -= dt;
    if (this.life <= 0) return false;

    this.vx *= this.friction;
    this.vy *= this.friction;
    this.vy += this.gravity * dt;

    this.x += this.vx * dt;
    this.y += this.vy * dt;

    var lifeRatio = this.life / this.maxLife;

    if (this.fadeOut) {
      this.alpha = lifeRatio;
    }

    if (this.shrink) {
      this.size = this.initialSize * lifeRatio;
    }

    return true;
  }

  draw(ctx) {
    if (this.life <= 0 || this.size < 0.2) return;

    ctx.save();
    ctx.globalAlpha = this.alpha;

    // Glow effect
    if (this.glow && this.glowSize > 0) {
      ctx.globalAlpha = this.alpha * 0.3;
      ctx.fillStyle = this.color;
      if (this.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size + this.glowSize, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(
          this.x - (this.size + this.glowSize) / 2,
          this.y - (this.size + this.glowSize) / 2,
          this.size + this.glowSize,
          this.size + this.glowSize
        );
      }
      ctx.globalAlpha = this.alpha;
    }

    ctx.fillStyle = this.color;

    switch (this.shape) {
      case 'circle':
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'diamond':
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.PI / 4);
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
        break;
      case 'square':
      default:
        ctx.fillRect(
          this.x - this.size / 2,
          this.y - this.size / 2,
          this.size,
          this.size
        );
        break;
    }

    ctx.restore();
  }
}

const particles = [];

function spawnParticles(x, y, count, color, spread, speed, life, size) {
  for (var i = 0; i < count; i++) {
    var angle = Math.random() * Math.PI * 2;
    var spd = speed * (0.3 + Math.random() * 0.7);
    var vx = Math.cos(angle) * spd;
    var vy = Math.sin(angle) * spd;
    var px = x + (Math.random() - 0.5) * spread;
    var py = y + (Math.random() - 0.5) * spread;
    var plife = life * (0.5 + Math.random() * 0.5);
    var psize = size * (0.5 + Math.random() * 0.5);
    var c = Array.isArray(color) ? color[randInt(0, color.length - 1)] : color;
    var p = new Particle(px, py, vx, vy, plife, c, psize);
    particles.push(p);
  }
}

function spawnExplosion(x, y, intensity) {
  // Candy explosion with colorful sprinkle-like particles
  var count = Math.floor(intensity * 10);
  var candyColors = ['#FF66AA', '#FFAA44', '#FFEE44', '#66DD88', '#66AAFF', '#CC88FF', '#FF4466', '#FFFFFF'];
  for (var i = 0; i < count; i++) {
    var angle = Math.random() * Math.PI * 2;
    var spd = (180 + Math.random() * 350) * (intensity / 3);
    var vx = Math.cos(angle) * spd;
    var vy = Math.sin(angle) * spd;
    var life = 0.4 + Math.random() * 0.7;
    var size = 2 + Math.random() * 5 * (intensity / 3);
    var p = new Particle(x, y, vx, vy, life, candyColors[randInt(0, candyColors.length - 1)], size);
    p.gravity = 300;
    p.friction = 0.96;
    p.shape = ['circle', 'square', 'diamond'][randInt(0, 2)];
    p.glow = Math.random() > 0.6;
    p.glowSize = 3;
    particles.push(p);
  }
  // Add a central bright flash particle
  var flashP = new Particle(x, y, 0, 0, 0.2, '#FFFFFF', intensity * 15);
  flashP.shape = 'circle';
  flashP.glow = true;
  flashP.glowSize = intensity * 8;
  flashP.gravity = 0;
  flashP.shrink = true;
  particles.push(flashP);
}

function spawnPowerUpCollect(x, y, type) {
  var colors;
  switch(type) {
    case 'senzu': colors = ['#FF88AA', '#FFAACC', '#FFFFFF']; break;
    case 'ki': colors = ['#FF4444', '#FFFFFF', '#FF8888']; break;
    case 'dragonball': colors = ['#FFD700', '#FFAA00', '#FFFFFF']; break;
    case 'speed': colors = ['#FFAADD', '#AADDFF', '#FFFFFF']; break;
    default: colors = ['#FFFF00', '#FFFFFF', '#FFDD00'];
  }
  // Radial burst of sparkles
  for (var i = 0; i < 12; i++) {
    var angle = (i / 12) * Math.PI * 2;
    var spd = 120 + Math.random() * 80;
    var p = new Particle(x, y, Math.cos(angle) * spd, Math.sin(angle) * spd, 0.5 + Math.random() * 0.3, colors[i % colors.length], 3 + Math.random() * 2);
    p.shape = 'diamond';
    p.glow = true;
    p.glowSize = 4;
    p.gravity = 0;
    p.friction = 0.95;
    particles.push(p);
  }
  // Rising text-like sparkle
  for (var i = 0; i < 5; i++) {
    var p = new Particle(x + (Math.random() - 0.5) * 20, y, (Math.random() - 0.5) * 40, -100 - Math.random() * 60, 0.6, '#FFFFFF', 2);
    p.shape = 'circle';
    p.glow = true;
    p.glowSize = 3;
    p.gravity = 0;
    particles.push(p);
  }
}

function spawnKiTrail(x, y, dirX) {
  for (var i = 0; i < 3; i++) {
    var vx = -dirX * (100 + Math.random() * 200);
    var vy = (Math.random() - 0.5) * 100;
    var life = 0.15 + Math.random() * 0.2;
    var size = 2 + Math.random() * 3;
    var colors = [COLORS.kiBlue, COLORS.kiBlueBright, COLORS.kiBlueCore];
    var p = new Particle(x, y, vx, vy, life, colors[randInt(0, 2)], size);
    p.shape = 'circle';
    p.glow = true;
    p.glowSize = 3;
    particles.push(p);
  }
}

function spawnAuraGlow(x, y, color, intensity) {
  var count = Math.floor(intensity * 3);
  for (var i = 0; i < count; i++) {
    var angle = Math.random() * Math.PI * 2;
    var dist = Math.random() * 15;
    var px = x + Math.cos(angle) * dist;
    var py = y + Math.sin(angle) * dist;
    var vx = (Math.random() - 0.5) * 80;
    var vy = -150 - Math.random() * 250;
    var life = 0.2 + Math.random() * 0.4;
    var size = 2 + Math.random() * 4;
    var p = new Particle(px, py, vx, vy, life, color, size);
    p.shape = 'diamond';
    p.glow = true;
    p.glowSize = 4;
    p.friction = 0.98;
    particles.push(p);
  }
}

function spawnCloudTrail(x, y) {
  for (var i = 0; i < 2; i++) {
    var vx = -100 - Math.random() * 150;
    var vy = (Math.random() - 0.5) * 60;
    var life = 0.3 + Math.random() * 0.4;
    var size = 4 + Math.random() * 6;
    var colors = [COLORS.cloudYellow, COLORS.cloudYellowLight, COLORS.cloudTrail];
    var p = new Particle(x, y, vx, vy, life, colors[randInt(0, 2)], size);
    p.shape = 'circle';
    p.friction = 0.96;
    particles.push(p);
  }
}

function spawnChargeSparkle(x, y, radius, color) {
  var angle = Math.random() * Math.PI * 2;
  var dist = radius * (0.6 + Math.random() * 0.4);
  var px = x + Math.cos(angle) * dist;
  var py = y + Math.sin(angle) * dist;
  // Move toward center
  var toX = x - px;
  var toY = y - py;
  var len = Math.sqrt(toX * toX + toY * toY) || 1;
  var spd = 200 + Math.random() * 300;
  var vx = (toX / len) * spd;
  var vy = (toY / len) * spd;
  var life = 0.2 + Math.random() * 0.3;
  var size = 1 + Math.random() * 3;
  var c = color || COLORS.auraChargeBlue;
  var p = new Particle(px, py, vx, vy, life, c, size);
  p.shape = 'diamond';
  p.glow = true;
  p.glowSize = 2;
  p.shrink = false;
  p.fadeOut = true;
  particles.push(p);
}

function updateParticles(dt) {
  for (var i = particles.length - 1; i >= 0; i--) {
    if (!particles[i].update(dt)) {
      particles.splice(i, 1);
    }
  }
}

function drawParticles(ctx) {
  for (var i = 0; i < particles.length; i++) {
    particles[i].draw(ctx);
  }
}

// ============================================================
// SECTION 5: CAMERA SYSTEM
// ============================================================

const camera = {
  x: 0,
  y: 0,
  shake: 0,
  shakeDecay: 0.9,
  targetX: 0,
  targetY: 0,
  offsetX: 0,
  offsetY: 0,
  smoothing: 0.1
};

function shakeScreen(intensity) {
  camera.shake = Math.max(camera.shake, intensity);
}

function updateCamera(dt) {
  // Apply screen shake
  if (camera.shake > 0.5) {
    camera.offsetX = (Math.random() - 0.5) * camera.shake * 2;
    camera.offsetY = (Math.random() - 0.5) * camera.shake * 2;
    camera.shake *= camera.shakeDecay;
  } else {
    camera.shake = 0;
    camera.offsetX = 0;
    camera.offsetY = 0;
  }

  // Smooth follow toward target
  camera.x = lerp(camera.x, camera.targetX, camera.smoothing);
  camera.y = lerp(camera.y, camera.targetY, camera.smoothing);
}

function applyCameraTransform(ctx) {
  ctx.translate(
    -Math.round(camera.x + camera.offsetX),
    -Math.round(camera.y + camera.offsetY)
  );
}

function resetCameraTransform(ctx) {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

// ============================================================
// SECTION 6: UTILITY FUNCTIONS
// ============================================================

function aabb(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function rand(min, max) {
  return min + Math.random() * (max - min);
}

function randInt(min, max) {
  return Math.floor(min + Math.random() * (max - min + 1));
}

// Screen flash effect global state
var screenFlash = {
  active: false,
  color: '#FFFFFF',
  alpha: 0,
  duration: 0,
  elapsed: 0
};

function flash(color, duration) {
  screenFlash.active = true;
  screenFlash.color = color || '#FFFFFF';
  screenFlash.alpha = 1.0;
  screenFlash.duration = duration || 0.2;
  screenFlash.elapsed = 0;
}

function updateFlash(dt) {
  if (!screenFlash.active) return;
  screenFlash.elapsed += dt;
  var t = screenFlash.elapsed / screenFlash.duration;
  if (t >= 1) {
    screenFlash.active = false;
    screenFlash.alpha = 0;
  } else {
    screenFlash.alpha = 1.0 - t;
  }
}

function drawFlash(ctx) {
  if (!screenFlash.active || screenFlash.alpha <= 0) return;
  ctx.save();
  ctx.globalAlpha = screenFlash.alpha;
  ctx.fillStyle = screenFlash.color;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  ctx.restore();
}

// ============================================================
// PIXEL TEXT SYSTEM
// ============================================================

// Each character is a 5x5 grid stored as a 25-character string of 1s and 0s
// Row-major order: chars[0..4] = row 0, chars[5..9] = row 1, etc.
const PIXEL_FONT = {
  'A': [
    0,1,1,1,0,
    1,0,0,0,1,
    1,1,1,1,1,
    1,0,0,0,1,
    1,0,0,0,1
  ],
  'B': [
    1,1,1,1,0,
    1,0,0,0,1,
    1,1,1,1,0,
    1,0,0,0,1,
    1,1,1,1,0
  ],
  'C': [
    0,1,1,1,1,
    1,0,0,0,0,
    1,0,0,0,0,
    1,0,0,0,0,
    0,1,1,1,1
  ],
  'D': [
    1,1,1,1,0,
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,0,0,1,
    1,1,1,1,0
  ],
  'E': [
    1,1,1,1,1,
    1,0,0,0,0,
    1,1,1,1,0,
    1,0,0,0,0,
    1,1,1,1,1
  ],
  'F': [
    1,1,1,1,1,
    1,0,0,0,0,
    1,1,1,1,0,
    1,0,0,0,0,
    1,0,0,0,0
  ],
  'G': [
    0,1,1,1,1,
    1,0,0,0,0,
    1,0,1,1,1,
    1,0,0,0,1,
    0,1,1,1,1
  ],
  'H': [
    1,0,0,0,1,
    1,0,0,0,1,
    1,1,1,1,1,
    1,0,0,0,1,
    1,0,0,0,1
  ],
  'I': [
    1,1,1,1,1,
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0,
    1,1,1,1,1
  ],
  'J': [
    0,0,0,0,1,
    0,0,0,0,1,
    0,0,0,0,1,
    1,0,0,0,1,
    0,1,1,1,0
  ],
  'K': [
    1,0,0,0,1,
    1,0,0,1,0,
    1,1,1,0,0,
    1,0,0,1,0,
    1,0,0,0,1
  ],
  'L': [
    1,0,0,0,0,
    1,0,0,0,0,
    1,0,0,0,0,
    1,0,0,0,0,
    1,1,1,1,1
  ],
  'M': [
    1,0,0,0,1,
    1,1,0,1,1,
    1,0,1,0,1,
    1,0,0,0,1,
    1,0,0,0,1
  ],
  'N': [
    1,0,0,0,1,
    1,1,0,0,1,
    1,0,1,0,1,
    1,0,0,1,1,
    1,0,0,0,1
  ],
  'O': [
    0,1,1,1,0,
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,0,0,1,
    0,1,1,1,0
  ],
  'P': [
    1,1,1,1,0,
    1,0,0,0,1,
    1,1,1,1,0,
    1,0,0,0,0,
    1,0,0,0,0
  ],
  'Q': [
    0,1,1,1,0,
    1,0,0,0,1,
    1,0,1,0,1,
    1,0,0,1,0,
    0,1,1,0,1
  ],
  'R': [
    1,1,1,1,0,
    1,0,0,0,1,
    1,1,1,1,0,
    1,0,0,1,0,
    1,0,0,0,1
  ],
  'S': [
    0,1,1,1,1,
    1,0,0,0,0,
    0,1,1,1,0,
    0,0,0,0,1,
    1,1,1,1,0
  ],
  'T': [
    1,1,1,1,1,
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0
  ],
  'U': [
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,0,0,1,
    0,1,1,1,0
  ],
  'V': [
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,0,0,1,
    0,1,0,1,0,
    0,0,1,0,0
  ],
  'W': [
    1,0,0,0,1,
    1,0,0,0,1,
    1,0,1,0,1,
    1,1,0,1,1,
    1,0,0,0,1
  ],
  'X': [
    1,0,0,0,1,
    0,1,0,1,0,
    0,0,1,0,0,
    0,1,0,1,0,
    1,0,0,0,1
  ],
  'Y': [
    1,0,0,0,1,
    0,1,0,1,0,
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0
  ],
  'Z': [
    1,1,1,1,1,
    0,0,0,1,0,
    0,0,1,0,0,
    0,1,0,0,0,
    1,1,1,1,1
  ],
  '0': [
    0,1,1,1,0,
    1,0,0,1,1,
    1,0,1,0,1,
    1,1,0,0,1,
    0,1,1,1,0
  ],
  '1': [
    0,0,1,0,0,
    0,1,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0,
    0,1,1,1,0
  ],
  '2': [
    0,1,1,1,0,
    1,0,0,0,1,
    0,0,1,1,0,
    0,1,0,0,0,
    1,1,1,1,1
  ],
  '3': [
    1,1,1,1,0,
    0,0,0,0,1,
    0,1,1,1,0,
    0,0,0,0,1,
    1,1,1,1,0
  ],
  '4': [
    1,0,0,1,0,
    1,0,0,1,0,
    1,1,1,1,1,
    0,0,0,1,0,
    0,0,0,1,0
  ],
  '5': [
    1,1,1,1,1,
    1,0,0,0,0,
    1,1,1,1,0,
    0,0,0,0,1,
    1,1,1,1,0
  ],
  '6': [
    0,1,1,1,0,
    1,0,0,0,0,
    1,1,1,1,0,
    1,0,0,0,1,
    0,1,1,1,0
  ],
  '7': [
    1,1,1,1,1,
    0,0,0,0,1,
    0,0,0,1,0,
    0,0,1,0,0,
    0,0,1,0,0
  ],
  '8': [
    0,1,1,1,0,
    1,0,0,0,1,
    0,1,1,1,0,
    1,0,0,0,1,
    0,1,1,1,0
  ],
  '9': [
    0,1,1,1,0,
    1,0,0,0,1,
    0,1,1,1,1,
    0,0,0,0,1,
    0,1,1,1,0
  ],
  ' ': [
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0
  ],
  '!': [
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,0,0,0,
    0,0,1,0,0
  ],
  '-': [
    0,0,0,0,0,
    0,0,0,0,0,
    0,1,1,1,0,
    0,0,0,0,0,
    0,0,0,0,0
  ],
  ':': [
    0,0,0,0,0,
    0,0,1,0,0,
    0,0,0,0,0,
    0,0,1,0,0,
    0,0,0,0,0
  ],
  '.': [
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,1,0,0
  ],
  ',': [
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,1,0,0,
    0,1,0,0,0
  ],
  '?': [
    0,1,1,1,0,
    1,0,0,0,1,
    0,0,0,1,0,
    0,0,0,0,0,
    0,0,0,1,0
  ],
  '/': [
    0,0,0,0,1,
    0,0,0,1,0,
    0,0,1,0,0,
    0,1,0,0,0,
    1,0,0,0,0
  ],
  '(': [
    0,0,1,0,0,
    0,1,0,0,0,
    0,1,0,0,0,
    0,1,0,0,0,
    0,0,1,0,0
  ],
  ')': [
    0,0,1,0,0,
    0,0,0,1,0,
    0,0,0,1,0,
    0,0,0,1,0,
    0,0,1,0,0
  ],
  '+': [
    0,0,0,0,0,
    0,0,1,0,0,
    0,1,1,1,0,
    0,0,1,0,0,
    0,0,0,0,0
  ],
  '\'': [
    0,0,1,0,0,
    0,0,1,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0
  ],
  '"': [
    0,1,0,1,0,
    0,1,0,1,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0
  ],
  '%': [
    1,0,0,0,1,
    0,0,0,1,0,
    0,0,1,0,0,
    0,1,0,0,0,
    1,0,0,0,1
  ],
  '#': [
    0,1,0,1,0,
    1,1,1,1,1,
    0,1,0,1,0,
    1,1,1,1,1,
    0,1,0,1,0
  ],
  '*': [
    0,0,0,0,0,
    0,1,0,1,0,
    0,0,1,0,0,
    0,1,0,1,0,
    0,0,0,0,0
  ],
  '=': [
    0,0,0,0,0,
    0,1,1,1,0,
    0,0,0,0,0,
    0,1,1,1,0,
    0,0,0,0,0
  ],
  '<': [
    0,0,0,1,0,
    0,0,1,0,0,
    0,1,0,0,0,
    0,0,1,0,0,
    0,0,0,1,0
  ],
  '>': [
    0,1,0,0,0,
    0,0,1,0,0,
    0,0,0,1,0,
    0,0,1,0,0,
    0,1,0,0,0
  ]
};

function drawPixelText(ctx, text, x, y, size, color) {
  ctx.fillStyle = color;
  var str = text.toUpperCase();
  var charWidth = 5;
  var charHeight = 5;
  var spacing = 1; // 1 pixel gap between characters
  var pixelSize = size;

  var cursorX = x;

  for (var c = 0; c < str.length; c++) {
    var ch = str[c];
    var glyph = PIXEL_FONT[ch];
    if (glyph) {
      for (var row = 0; row < charHeight; row++) {
        for (var col = 0; col < charWidth; col++) {
          if (glyph[row * charWidth + col]) {
            ctx.fillRect(
              cursorX + col * pixelSize,
              y + row * pixelSize,
              pixelSize,
              pixelSize
            );
          }
        }
      }
    }
    cursorX += (charWidth + spacing) * pixelSize;
  }
}

function getPixelTextWidth(text, size) {
  var charWidth = 5;
  var spacing = 1;
  return text.length * (charWidth + spacing) * size - spacing * size;
}

function drawPixelTextCentered(ctx, text, centerX, y, size, color) {
  var w = getPixelTextWidth(text, size);
  drawPixelText(ctx, text, centerX - w / 2, y, size, color);
}

function drawPixelTextWithShadow(ctx, text, x, y, size, color, shadowColor) {
  var sc = shadowColor || '#000000';
  drawPixelText(ctx, text, x + size, y + size, size, sc);
  drawPixelText(ctx, text, x, y, size, color);
}

function drawPixelTextCenteredWithShadow(ctx, text, centerX, y, size, color, shadowColor) {
  var w = getPixelTextWidth(text, size);
  var x = centerX - w / 2;
  drawPixelTextWithShadow(ctx, text, x, y, size, color, shadowColor);
}

// === END CORE ENGINE ===
// === PLAYER CHARACTER ===

// ---------------------------------------------------------------------------
// Projectile: Ki Blast  (Yellow energy ball, 8Ã—8)
// ---------------------------------------------------------------------------
class KiBlast {
  constructor(x, y, dir) {
    this.x = x;
    this.y = y;
    this.dir = dir;          // 1 = right, -1 = left
    this.w = 8;
    this.h = 8;
    this.speed = 350;
    this.damage = 10;
    this.alive = true;
    this.age = 0;
    this.trailTimer = 0;
  }

  update(dt) {
    this.x += this.speed * this.dir * dt * 60;
    this.age += dt;
    this.trailTimer += dt;

    // Spawn trail particles every ~0.03s
    if (this.trailTimer >= 0.03) {
      this.trailTimer = 0;
      spawnParticles(
        this.x - this.dir * 4, this.y,
        3,                                       // count
        { r: 204, g: 136, b: 68 },              // color (cookie crumbs)
        1.5,                                     // size
        0.6,                                     // speed
        0.25,                                    // life
        true                                     // randomDir
      );
    }

    // Remove when off-screen (generous margin for camera)
    if (this.x < camera.x - 60 || this.x > camera.x + CANVAS_W + 60 ||
        this.y < -60 || this.y > CANVAS_H + 60) {
      this.alive = false;
    }
  }

  draw(ctx) {
    const sx = this.x - camera.x;
    const sy = this.y;

    ctx.save();
    // Brown circle (cookie base)
    ctx.fillStyle = '#CC8844';
    ctx.beginPath();
    ctx.arc(sx + 4, sy + 4, 6, 0, Math.PI * 2);
    ctx.fill();

    // Darker edge
    ctx.fillStyle = '#AA6633';
    ctx.beginPath();
    ctx.arc(sx + 4, sy + 4, 6, 0, Math.PI * 2);
    ctx.stroke();

    // Chocolate chips (3 small dark dots)
    ctx.fillStyle = '#553311';
    ctx.fillRect(sx + 1, sy + 2, 2, 2);
    ctx.fillRect(sx + 5, sy + 5, 2, 2);
    ctx.fillRect(sx + 3, sy + 7, 2, 2);
    ctx.restore();
  }
}

// ---------------------------------------------------------------------------
// Projectile: Kamehameha Beam
// ---------------------------------------------------------------------------
class KamehamehaBeam {
  constructor(x, y) {
    this.x = x;                 // origin x (Goku's hands)
    this.y = y;                 // origin y
    this.width = 4;             // current beam width (grows)
    this.maxWidth = 24;
    this.growTime = 0.5;        // seconds to reach max width
    this.duration = 1.5;        // total lifespan in seconds
    this.age = 0;
    this.damage = 2;            // per frame (continuous)
    this.alive = true;
    this.particleTimer = 0;
  }

  update(dt) {
    this.age += dt;

    // Grow beam width
    if (this.age < this.growTime) {
      this.width = 4 + (this.maxWidth - 4) * (this.age / this.growTime);
    } else {
      this.width = this.maxWidth;
    }

    // Expire after duration
    if (this.age >= this.duration) {
      this.alive = false;
    }

    // Edge particles
    this.particleTimer += dt;
    if (this.particleTimer >= 0.04) {
      this.particleTimer = 0;
      const beamLen = CANVAS_W + camera.x - this.x;
      const rx = this.x + Math.random() * beamLen;
      const ry = this.y + (Math.random() - 0.5) * this.width;
      spawnParticles(
        rx, ry,
        1,
        { r: 255, g: 136, b: 204 },
        2,
        0.8,
        0.3,
        true
      );
    }
  }

  draw(ctx) {
    if (!this.alive) return;
    const sx = this.x - camera.x;
    const sy = this.y;
    const beamLen = CANVAS_W - sx + 20;

    ctx.save();

    // Fade out near end of life
    const fadeStart = this.duration - 0.3;
    if (this.age > fadeStart) {
      ctx.globalAlpha = Math.max(0, 1 - (this.age - fadeStart) / 0.3);
    }

    // Outer glow (pink candy glow)
    ctx.fillStyle = 'rgba(255, 136, 204, 0.25)';
    ctx.fillRect(sx, sy - this.width * 0.75, beamLen, this.width * 1.5);

    // Rainbow candy stripes
    const stripeColors = ['#FF6688', '#FFAA44', '#FFEE44', '#66DD88', '#66AAFF'];
    const stripeH = this.width / stripeColors.length;
    for (let i = 0; i < stripeColors.length; i++) {
      ctx.fillStyle = stripeColors[i];
      ctx.fillRect(sx, sy - this.width / 2 + stripeH * i, beamLen, stripeH);
    }

    // White core
    ctx.fillStyle = '#ffffff';
    const coreW = this.width * 0.2;
    ctx.fillRect(sx, sy - coreW / 2, beamLen, coreW);

    // Origin flare (circle at hand position)
    const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, this.width);
    gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
    gradient.addColorStop(0.4, 'rgba(255,136,204,0.5)');
    gradient.addColorStop(1, 'rgba(255,100,180,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(sx, sy, this.width, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  getHitbox() {
    return {
      x: this.x,
      y: this.y - this.width / 2,
      w: CANVAS_W + camera.x - this.x,
      h: this.width
    };
  }
}

// ---------------------------------------------------------------------------
// Projectile: Spirit Bomb
// ---------------------------------------------------------------------------
class SpiritBomb {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 16;           // starting radius
    this.maxRadius = 80;
    this.growDuration = 2.0;    // seconds to reach max size
    this.age = 0;
    this.damage = 100;
    this.alive = true;
    this.launched = false;
    this.speed = 120;           // pixels per second after launch
    this.swirlAngle = 0;
    this.particleTimer = 0;
    this.hitTargets = new Set(); // prevent multi-hit on same enemy
  }

  update(dt) {
    this.age += dt;
    this.swirlAngle += dt * 4;

    // Growth phase
    if (!this.launched) {
      if (this.age < this.growDuration) {
        this.radius = 16 + (this.maxRadius - 16) * (this.age / this.growDuration);
      } else {
        this.radius = this.maxRadius;
        this.launched = true;
      }
    }

    // Move forward after launch
    if (this.launched) {
      this.x += this.speed * dt * 60;
    }

    // Swirling energy-gather particles
    this.particleTimer += dt;
    if (this.particleTimer >= 0.05) {
      this.particleTimer = 0;
      const angle = Math.random() * Math.PI * 2;
      const dist = this.radius + 20 + Math.random() * 40;
      const px = this.x + Math.cos(angle) * dist;
      const py = this.y + Math.sin(angle) * dist;
      spawnParticles(
        px, py,
        1,
        Math.random() > 0.5 ? { r: 255, g: 102, b: 170 } : { r: 255, g: 170, b: 68 },
        2.5,
        1.2,
        0.5,
        true
      );
    }

    // Remove when off-screen
    if (this.x - this.radius > camera.x + CANVAS_W + 100) {
      this.alive = false;
    }
  }

  draw(ctx) {
    if (!this.alive) return;
    const sx = this.x - camera.x;
    const sy = this.y;

    ctx.save();

    // Massive outer glow (pink candy glow)
    const outerGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, this.radius * 1.8);
    outerGrad.addColorStop(0, 'rgba(255, 170, 221, 0.15)');
    outerGrad.addColorStop(0.5, 'rgba(255, 170, 221, 0.08)');
    outerGrad.addColorStop(1, 'rgba(255, 170, 221, 0)');
    ctx.fillStyle = outerGrad;
    ctx.beginPath();
    ctx.arc(sx, sy, this.radius * 1.8, 0, Math.PI * 2);
    ctx.fill();

    // Swirling bands (rotating arcs - pink/orange lollipop)
    for (let i = 0; i < 4; i++) {
      const a = this.swirlAngle + (Math.PI / 2) * i;
      ctx.strokeStyle = i % 2 === 0
        ? `rgba(255, 102, 170, ${0.3 + 0.1 * Math.sin(this.age * 6 + i)})`
        : `rgba(255, 170, 68, ${0.3 + 0.1 * Math.sin(this.age * 6 + i)})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sx, sy, this.radius * 0.7, a, a + Math.PI * 0.6);
      ctx.stroke();
    }

    // Main sphere gradient (pink and orange lollipop)
    const mainGrad = ctx.createRadialGradient(sx - this.radius * 0.2, sy - this.radius * 0.2, 0, sx, sy, this.radius);
    mainGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
    mainGrad.addColorStop(0.3, 'rgba(255, 102, 170, 0.85)');
    mainGrad.addColorStop(0.7, 'rgba(255, 170, 68, 0.6)');
    mainGrad.addColorStop(1, 'rgba(255, 102, 170, 0.3)');
    ctx.fillStyle = mainGrad;
    ctx.beginPath();
    ctx.arc(sx, sy, this.radius, 0, Math.PI * 2);
    ctx.fill();

    // Lollipop stick
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(sx - 2, sy + this.radius, 4, 20);

    // Bright white core
    const coreGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, this.radius * 0.35);
    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    coreGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(sx, sy, this.radius * 0.35, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  getHitbox() {
    return {
      x: this.x - this.radius,
      y: this.y - this.radius,
      w: this.radius * 2,
      h: this.radius * 2
    };
  }

  explode() {
    // Huge explosion effect
    spawnParticles(this.x, this.y, 60, { r: 255, g: 255, b: 255 }, 6, 5, 1.0, true);
    spawnParticles(this.x, this.y, 40, { r: 255, g: 102, b: 170 }, 5, 4, 0.8, true);
    spawnParticles(this.x, this.y, 30, { r: 255, g: 170, b: 68 }, 4, 3, 0.6, true);
    shakeScreen(20, 0.6);
    playSound('spiritBomb');
    this.alive = false;
  }
}

// ---------------------------------------------------------------------------
// Goku Player Class
// ---------------------------------------------------------------------------
class Player {
  constructor() {
    // Position & physics
    this.x = 120;
    this.y = CANVAS_H / 2;
    this.vx = 0;
    this.vy = 0;
    this.w = 48;             // Goku sprite width
    this.h = 56;             // Goku sprite height
    this.cloudW = 78;        // nimbus cloud width (scaled up ~40%)
    this.cloudH = 31;        // nimbus cloud height (scaled up ~40%)
    this.moveSpeed = 200;    // pixels per second (max speed)

    // Smooth movement physics
    this.acceleration = 800;   // how fast we reach max speed (px/s^2)
    this.deceleration = 600;   // how fast we slow down when keys released (px/s^2)
    this.velocityX = 0;        // current smooth velocity X
    this.velocityY = 0;        // current smooth velocity Y

    // Stats
    this.hp = 150;
    this.maxHp = 150;
    this.ki = 50;
    this.maxKi = 100;
    this.kiRegenRate = 12;   // per second
    this.lives = 4;
    this.score = 0;

    // State management
    this.state = 'idle';     // idle, moving, attacking, charging, hit, dead
    this.facing = 1;         // 1 = right, -1 = left

    // Projectiles owned by player
    this.projectiles = [];

    // Attack cooldowns (in seconds)
    this.kiBlastCooldown = 0;
    this.kiBlastCooldownMax = 0.3;
    this.meleeCooldown = 0;
    this.meleeCooldownMax = 0.4;

    // Melee hitbox
    this.meleeActive = false;
    this.meleeTimer = 0;
    this.meleeDuration = 0.15;
    this.meleeDamage = 15;

    // Kamehameha charging
    this.chargingKame = false;
    this.kameChargeTime = 0;
    this.kameMinCharge = 0.5;
    this.kameKiCost = 30;
    this.kameFiring = false;

    // Spirit bomb
    this.spiritBombKiCost = 100;

    // Invincibility
    this.invincible = false;
    this.invincibleTimer = 0;
    this.invincibleDuration = 1.5;
    this.flashToggle = false;
    this.flashTimer = 0;

    // Hit stun
    this.hitStunTimer = 0;
    this.hitStunDuration = 0.3;

    // Cloud bobbing
    this.bobTime = 0;
    this.bobAmplitude = 5;
    this.bobSpeed = 3;

    // Aura particles
    this.auraTimer = 0;

    // Animation timers
    this.animTimer = 0;
    this.attackAnimTimer = 0;
    this.attackAnimDuration = 0.2;

    // Speed boost
    this.speedBoostTimer = 0;
    this.baseMoveSpeed = 200;

    // Dead state
    this.dead = false;
    this.deathTimer = 0;
    this.deathDuration = 1.5;
  }

  update(dt) {
    if (this.dead) {
      this.deathTimer += dt;
      if (this.deathTimer >= this.deathDuration) {
        if (this.lives > 0) {
          this.respawn();
        }
        // else game over is handled externally
      }
      return;
    }

    this.animTimer += dt;

    // ----- Hit stun -----
    if (this.hitStunTimer > 0) {
      this.hitStunTimer -= dt;
      this.state = 'hit';
      // Still decrement invincibility
      this.updateInvincibility(dt);
      return;
    }

    // ----- Invincibility timer -----
    this.updateInvincibility(dt);

    // ----- Ki regeneration -----
    this.ki = Math.min(this.maxKi, this.ki + this.kiRegenRate * dt);

    // ----- Speed boost -----
    if (this.speedBoostTimer > 0) {
      this.speedBoostTimer -= dt;
      this.moveSpeed = this.baseMoveSpeed * 1.5;
    } else {
      this.moveSpeed = this.baseMoveSpeed;
    }

    // ----- Cooldown timers -----
    if (this.kiBlastCooldown > 0) this.kiBlastCooldown -= dt;
    if (this.meleeCooldown > 0) this.meleeCooldown -= dt;

    // ----- Melee hitbox timer -----
    if (this.meleeActive) {
      this.meleeTimer -= dt;
      if (this.meleeTimer <= 0) {
        this.meleeActive = false;
      }
    }

    // ----- Attack animation timer -----
    if (this.attackAnimTimer > 0) {
      this.attackAnimTimer -= dt;
    }

    // ----- Kamehameha charge -----
    if (this.chargingKame) {
      this.kameChargeTime += dt;
      this.state = 'charging';

      // Release or key up triggers firing
      if (!keys.c && !keys.KeyC) {
        if (this.kameChargeTime >= this.kameMinCharge && this.ki >= this.kameKiCost) {
          this.fireKamehameha();
        }
        this.chargingKame = false;
        this.kameChargeTime = 0;
      }
    }

    // ----- Movement (smooth acceleration/deceleration) -----
    let inputX = 0;
    let inputY = 0;
    if (!this.chargingKame && !this.kameFiring) {
      if (keys.ArrowLeft || keys.left)  { inputX = -1; this.facing = -1; }
      if (keys.ArrowRight || keys.right) { inputX = 1;  this.facing = 1; }
      if (keys.ArrowUp || keys.up)    inputY = -1;
      if (keys.ArrowDown || keys.down)  inputY = 1;

      // Normalize diagonal input
      if (inputX !== 0 && inputY !== 0) {
        const inv = 1 / Math.SQRT2;
        inputX *= inv;
        inputY *= inv;
      }
    }

    // Target velocity based on input
    const targetVX = inputX * this.moveSpeed;
    const targetVY = inputY * this.moveSpeed;

    // Smoothly accelerate toward target velocity
    if (inputX !== 0) {
      // Accelerate toward target
      if (this.velocityX < targetVX) {
        this.velocityX = Math.min(targetVX, this.velocityX + this.acceleration * dt);
      } else if (this.velocityX > targetVX) {
        this.velocityX = Math.max(targetVX, this.velocityX - this.acceleration * dt);
      }
    } else {
      // Decelerate to zero
      if (this.velocityX > 0) {
        this.velocityX = Math.max(0, this.velocityX - this.deceleration * dt);
      } else if (this.velocityX < 0) {
        this.velocityX = Math.min(0, this.velocityX + this.deceleration * dt);
      }
    }

    if (inputY !== 0) {
      if (this.velocityY < targetVY) {
        this.velocityY = Math.min(targetVY, this.velocityY + this.acceleration * dt);
      } else if (this.velocityY > targetVY) {
        this.velocityY = Math.max(targetVY, this.velocityY - this.acceleration * dt);
      }
    } else {
      if (this.velocityY > 0) {
        this.velocityY = Math.max(0, this.velocityY - this.deceleration * dt);
      } else if (this.velocityY < 0) {
        this.velocityY = Math.min(0, this.velocityY + this.deceleration * dt);
      }
    }

    // Clamp smooth velocity to max speed (including diagonals)
    const currentSpeed = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
    if (currentSpeed > this.moveSpeed) {
      const scale = this.moveSpeed / currentSpeed;
      this.velocityX *= scale;
      this.velocityY *= scale;
    }

    // Store for external use (collision, etc.)
    this.vx = this.velocityX;
    this.vy = this.velocityY;

    // Apply movement
    this.x += this.velocityX * dt;
    this.y += this.velocityY * dt;

    // Bound to screen (relative to camera)
    const leftBound = camera.x + 16;
    const rightBound = camera.x + CANVAS_W - 16 - this.w;
    const topBound = 16;
    const bottomBound = CANVAS_H - 16 - this.h - this.cloudH;

    if (this.x < leftBound) { this.x = leftBound; this.velocityX = 0; }
    if (this.x > rightBound) { this.x = rightBound; this.velocityX = 0; }
    if (this.y < topBound) { this.y = topBound; this.velocityY = 0; }
    if (this.y > bottomBound) { this.y = bottomBound; this.velocityY = 0; }

    // ----- Determine state for drawing -----
    const isMoving = Math.abs(this.velocityX) > 10 || Math.abs(this.velocityY) > 10;
    if (this.kameFiring) {
      this.state = 'firing';
    } else if (this.chargingKame) {
      this.state = 'charging';
    } else if (this.attackAnimTimer > 0) {
      // Keep attack state from last attack
    } else if (isMoving) {
      this.state = 'moving';
    } else {
      this.state = 'idle';
    }

    // ----- Attacks -----
    // Z: Ki Blast
    if ((keys.z || keys.KeyZ) && !this.chargingKame && !this.kameFiring) {
      if (this.kiBlastCooldown <= 0 && this.ki >= 5) {
        this.fireKiBlast();
      }
    }

    // X: Melee
    if ((keys.x || keys.KeyX) && !this.chargingKame && !this.kameFiring) {
      if (this.meleeCooldown <= 0) {
        this.doMelee();
      }
    }

    // C: Kamehameha charge (start)
    if ((keys.c || keys.KeyC) && !this.chargingKame && !this.kameFiring) {
      if (this.ki >= this.kameKiCost) {
        this.chargingKame = true;
        this.kameChargeTime = 0;
        playSound('kamehameha');
      }
    }

    // V: Spirit Bomb
    if ((keys.v || keys.KeyV) && !this.chargingKame && !this.kameFiring) {
      if (this.ki >= this.spiritBombKiCost) {
        this.fireSpiritBomb();
      }
    }

    // ----- Cloud bobbing -----
    this.bobTime += dt * this.bobSpeed;

    // ----- Update projectiles -----
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      this.projectiles[i].update(dt);
      if (!this.projectiles[i].alive) {
        this.projectiles.splice(i, 1);
      }
    }

    // ----- Kamehameha firing state cleanup -----
    if (this.kameFiring) {
      let anyBeamAlive = false;
      for (const p of this.projectiles) {
        if (p instanceof KamehamehaBeam && p.alive) {
          anyBeamAlive = true;
          break;
        }
      }
      if (!anyBeamAlive) {
        this.kameFiring = false;
      }
    }

    // ----- Aura effect when Ki > 80 -----
    if (this.ki > 80) {
      this.auraTimer += dt;
      if (this.auraTimer >= 0.06) {
        this.auraTimer = 0;
        const ax = this.x + this.w / 2 + (Math.random() - 0.5) * this.w;
        const ay = this.y + this.h + (Math.random() - 0.5) * 10;
        spawnParticles(
          ax, ay,
          1,
          { r: 255, g: 220, b: 50 },
          2.5,
          1.5,
          0.4,
          false  // upward
        );
      }
    }

    // ----- Cloud trail particles when moving -----
    if (this.state === 'moving') {
      if (Math.random() < 0.3) {
        const cx = this.x + this.w / 2 - this.facing * 20;
        const cy = this.y + this.h + this.cloudH / 2 + Math.sin(this.bobTime) * this.bobAmplitude;
        spawnParticles(
          cx, cy,
          1,
          { r: 255, g: 230, b: 120 },
          3,
          0.5,
          0.5,
          true
        );
      }
    }
  }

  updateInvincibility(dt) {
    if (this.invincible) {
      this.invincibleTimer -= dt;
      this.flashTimer += dt;
      if (this.flashTimer >= 0.08) {
        this.flashTimer = 0;
        this.flashToggle = !this.flashToggle;
      }
      if (this.invincibleTimer <= 0) {
        this.invincible = false;
        this.flashToggle = false;
      }
    }
  }

  fireKiBlast() {
    this.ki -= 5;
    this.kiBlastCooldown = this.kiBlastCooldownMax;
    const bx = this.x + this.w / 2 + this.facing * 20;
    const by = this.y + this.h / 2;
    var blast = new KiBlast(bx, by, this.facing);
    this.projectiles.push(blast);
    projectiles.push(blast);
    this.state = 'kiBlast';
    this.attackAnimTimer = this.attackAnimDuration;
    playSound('kiBlast');
  }

  doMelee() {
    this.meleeCooldown = this.meleeCooldownMax;
    this.meleeActive = true;
    this.meleeTimer = this.meleeDuration;
    this.state = 'melee';
    this.attackAnimTimer = this.attackAnimDuration;
    playSound('melee');
  }

  fireKamehameha() {
    this.ki -= this.kameKiCost;
    const bx = this.x + this.w / 2 + this.facing * 22;
    const by = this.y + this.h / 2;
    var beam = new KamehamehaBeam(bx, by);
    this.projectiles.push(beam);
    projectiles.push(beam);
    this.kameFiring = true;
    this.state = 'firing';
    shakeScreen(6, 0.3);
    playSound('kamehameha');
  }

  fireSpiritBomb() {
    this.ki -= this.spiritBombKiCost;
    const bx = this.x + this.w / 2;
    const by = this.y - 30;
    var bomb = new SpiritBomb(bx, by);
    this.projectiles.push(bomb);
    projectiles.push(bomb);
    this.state = 'spiritBomb';
    this.attackAnimTimer = 2.2;     // long pose while spirit bomb charges
    shakeScreen(4, 1.0);
    playSound('spiritBomb');
  }

  getMeleeHitbox() {
    if (!this.meleeActive) return null;
    const mx = this.facing === 1 ? this.x + this.w : this.x - 24;
    return {
      x: mx,
      y: this.y + 4,
      w: 24,
      h: this.h - 8
    };
  }

  takeDamage(amount) {
    if (this.invincible || this.dead) return;

    this.hp -= amount;
    this.invincible = true;
    this.invincibleTimer = this.invincibleDuration;
    this.flashTimer = 0;
    this.flashToggle = false;
    this.hitStunTimer = this.hitStunDuration;
    this.state = 'hit';

    // Knockback: reduce velocity on hit
    this.velocityX *= 0.3;
    this.velocityY *= 0.3;

    // Cancel charging
    this.chargingKame = false;
    this.kameChargeTime = 0;

    shakeScreen(8, 0.25);
    playSound('hit');

    // Hit particles
    spawnParticles(
      this.x + this.w / 2, this.y + this.h / 2,
      8,
      { r: 255, g: 100, b: 100 },
      2,
      2,
      0.4,
      true
    );

    if (this.hp <= 0) {
      this.hp = 0;
      this.die();
    }
  }

  die() {
    this.dead = true;
    this.deathTimer = 0;
    this.lives--;
    this.state = 'dead';

    // Big death explosion
    spawnParticles(
      this.x + this.w / 2, this.y + this.h / 2,
      30,
      { r: 255, g: 200, b: 50 },
      4,
      4,
      0.8,
      true
    );
    shakeScreen(12, 0.5);
    playSound('explosion');
  }

  respawn() {
    this.dead = false;
    this.hp = this.maxHp;
    this.ki = 0;
    this.x = camera.x + 120;
    this.y = CANVAS_H / 2;
    this.velocityX = 0;
    this.velocityY = 0;
    this.vx = 0;
    this.vy = 0;
    this.state = 'idle';
    this.invincible = true;
    this.invincibleTimer = 2.0;   // longer invincibility after respawn
    this.hitStunTimer = 0;
    this.chargingKame = false;
    this.kameFiring = false;
    this.kameChargeTime = 0;
    this.meleeActive = false;
    this.projectiles = [];
  }

  getHitbox() {
    return {
      x: this.x + 4,
      y: this.y + 4,
      w: this.w - 8,
      h: this.h + this.cloudH - 8
    };
  }

  draw(ctx) {
    if (this.dead) {
      // Draw fading Goku briefly
      if (this.deathTimer < 0.5) {
        ctx.save();
        ctx.globalAlpha = 1 - this.deathTimer / 0.5;
        this.drawFull(ctx);
        ctx.restore();
      }
      return;
    }

    // Invincibility flashing - skip drawing every other flash frame
    if (this.invincible && this.flashToggle) return;

    this.drawFull(ctx);
  }

  drawFull(ctx) {
    const sx = this.x - camera.x;
    const bobOffset = Math.sin(this.bobTime) * this.bobAmplitude;
    const cloudY = this.y + this.h + bobOffset;
    const gokuY = this.y + bobOffset;

    // ----- Aura glow when ki > 80 -----
    if (this.ki > 80 && !this.dead) {
      ctx.save();
      const auraIntensity = (this.ki - 80) / 20; // 0 to 1
      const aGrad = ctx.createRadialGradient(
        sx + this.w / 2, gokuY + this.h / 2, 5,
        sx + this.w / 2, gokuY + this.h / 2, 50
      );
      aGrad.addColorStop(0, `rgba(255, 220, 50, ${0.25 * auraIntensity})`);
      aGrad.addColorStop(0.5, `rgba(255, 200, 0, ${0.12 * auraIntensity})`);
      aGrad.addColorStop(1, 'rgba(255, 180, 0, 0)');
      ctx.fillStyle = aGrad;
      ctx.beginPath();
      ctx.arc(sx + this.w / 2, gokuY + this.h / 2, 50, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // ----- Kamehameha charge glow -----
    if (this.chargingKame) {
      ctx.save();
      const intensity = Math.min(1, this.kameChargeTime / this.kameMinCharge);
      const glowR = 8 + intensity * 14;
      const handX = sx + this.w / 2 - this.facing * 8;
      const handY = gokuY + this.h / 2 + 2;
      const kGrad = ctx.createRadialGradient(handX, handY, 0, handX, handY, glowR);
      kGrad.addColorStop(0, `rgba(150, 200, 255, ${0.9 * intensity})`);
      kGrad.addColorStop(0.5, `rgba(80, 140, 255, ${0.5 * intensity})`);
      kGrad.addColorStop(1, 'rgba(40, 80, 255, 0)');
      ctx.fillStyle = kGrad;
      ctx.beginPath();
      ctx.arc(handX, handY, glowR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Draw sprite based on state
    this.drawSprite(ctx, sx, gokuY, this.state);

    // Draw Nimbus Cloud
    this.drawCloud(ctx, sx + this.w / 2, cloudY);

    // Draw melee hitbox effect (candy cane stripes)
    if (this.meleeActive) {
      const mhb = this.getMeleeHitbox();
      if (mhb) {
        ctx.save();
        // Swoosh arc effect with candy cane red/white stripes
        const arcX = mhb.x - camera.x + mhb.w / 2;
        const arcY = mhb.y + mhb.h / 2;
        const stripeColors = ['#FF4444', '#FFFFFF', '#FF4444', '#FFFFFF', '#FF4444'];
        const arcStart = this.facing === 1 ? -Math.PI * 0.4 : Math.PI * 0.6;
        const arcEnd = this.facing === 1 ? Math.PI * 0.4 : Math.PI * 1.4;
        const arcCenter = this.facing === 1 ? arcX - 12 : arcX + 12;
        const arcSpan = arcEnd - arcStart;
        const stripeArc = arcSpan / stripeColors.length;
        for (let si = 0; si < stripeColors.length; si++) {
          ctx.beginPath();
          ctx.strokeStyle = stripeColors[si];
          ctx.lineWidth = 3;
          ctx.globalAlpha = 0.5;
          ctx.arc(arcCenter, arcY, 18, arcStart + stripeArc * si, arcStart + stripeArc * (si + 1));
          ctx.stroke();
        }
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#FF4444';
        ctx.beginPath();
        ctx.arc(arcCenter, arcY, 18, arcStart, arcEnd);
        ctx.fill();
        ctx.restore();
      }
    }

    // Draw projectiles
    for (const p of this.projectiles) {
      p.draw(ctx);
    }
  }

  drawCloud(ctx, cx, cy) {
    // Nimbus Cloud: golden-yellow fluffy cloud made of overlapping circles
    ctx.save();

    const stretch = this.state === 'moving' ? 1.15 : 1.0;
    const squash = this.state === 'moving' ? 0.85 : 1.0;

    // Shadow underneath
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.beginPath();
    ctx.ellipse(cx, cy + 14, 31 * stretch, 7 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Cloud base color
    const cloudColor = '#FFD54F';       // golden yellow
    const cloudLight = '#FFECB3';       // lighter highlight
    const cloudDark = '#FFC107';        // darker shadow
    const cloudBright = '#FFE082';      // extra bright highlight

    // Bottom cloud puffs (darker)
    ctx.fillStyle = cloudDark;
    ctx.beginPath();
    ctx.ellipse(cx - 14 * stretch, cy + 4, 17 * stretch, 10 * squash, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 14 * stretch, cy + 4, 17 * stretch, 10 * squash, 0, 0, Math.PI * 2);
    ctx.fill();
    // Extra bottom puff for fluffiness
    ctx.beginPath();
    ctx.ellipse(cx, cy + 5, 14 * stretch, 9 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Main cloud body (middle)
    ctx.fillStyle = cloudColor;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 25 * stretch, 13 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Left puff
    ctx.beginPath();
    ctx.ellipse(cx - 20 * stretch, cy - 1, 14 * stretch, 11 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Right puff
    ctx.beginPath();
    ctx.ellipse(cx + 20 * stretch, cy - 1, 14 * stretch, 11 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Extra side puffs for fluffier look
    ctx.fillStyle = cloudBright;
    ctx.beginPath();
    ctx.ellipse(cx - 10 * stretch, cy - 3, 12 * stretch, 9 * squash, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 10 * stretch, cy - 3, 12 * stretch, 9 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Top highlights (lighter)
    ctx.fillStyle = cloudLight;
    ctx.beginPath();
    ctx.ellipse(cx - 6, cy - 6 * squash, 14 * stretch, 7 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(cx + 11 * stretch, cy - 4 * squash, 10 * stretch, 6 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Extra top puff for fluffiness
    ctx.beginPath();
    ctx.ellipse(cx - 14 * stretch, cy - 5 * squash, 8 * stretch, 5 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tiny bright spot (specular)
    ctx.fillStyle = '#FFF9C4';
    ctx.beginPath();
    ctx.ellipse(cx - 3, cy - 7 * squash, 6 * stretch, 3 * squash, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  drawSprite(ctx, x, y, state) {
    // Goku drawn programmatically with canvas primitives
    // x, y = top-left of Goku sprite (32x40)
    ctx.save();

    const centerX = x + this.w / 2;
    const f = this.facing;   // 1 = right, -1 = left

    // Color palette (brighter for visibility)
    const SKIN = '#FFD699';       // skin tone (brighter)
    const SKIN_DARK = '#FFC266';  // skin shadow (brighter)
    const GI_ORANGE = '#FF8C00';  // gi top/bottom (brighter orange)
    const GI_DARK = '#F57C00';    // gi shadow (brighter)
    const BELT_BLUE = '#1E88E5';  // belt / wristbands (brighter blue)
    const HAIR_BLACK = '#1A1A1A'; // hair
    const BOOT_BLUE = '#1565C0';  // boots (brighter)
    const WHITE = '#FFFFFF';       // eyes / highlights
    const EYE_BLACK = '#000000';

    // ----- Positions reference (scaled up ~40%) -----
    // Head center
    const headX = centerX;
    const headY = y + 14;
    const headR = 11;

    // Body
    const bodyTop = y + 25;
    const bodyW = 20;
    const bodyH = 17;

    // Legs
    const legTop = bodyTop + bodyH;
    const legW = 8;
    const legH = 14;

    // ----- DRAW LEGS (behind body) -----
    // Left leg
    ctx.fillStyle = GI_ORANGE;
    ctx.fillRect(centerX - 10, legTop, legW, legH);
    // Right leg
    ctx.fillRect(centerX + 2, legTop, legW, legH);

    // Boots
    ctx.fillStyle = BOOT_BLUE;
    ctx.fillRect(centerX - 11, legTop + legH - 6, legW + 2, 6);
    ctx.fillRect(centerX + 2, legTop + legH - 6, legW + 2, 6);

    // ----- DRAW BODY / TORSO -----
    ctx.fillStyle = GI_ORANGE;
    ctx.fillRect(centerX - bodyW / 2, bodyTop, bodyW, bodyH);

    // Gi shadow (left side fold)
    ctx.fillStyle = GI_DARK;
    ctx.fillRect(centerX - bodyW / 2, bodyTop, 4, bodyH);

    // Belt / sash
    ctx.fillStyle = BELT_BLUE;
    ctx.fillRect(centerX - bodyW / 2 - 1, bodyTop + bodyH - 4, bodyW + 2, 4);

    // Gi collar V-neck detail
    ctx.fillStyle = SKIN;
    ctx.beginPath();
    ctx.moveTo(centerX - 4, bodyTop);
    ctx.lineTo(centerX, bodyTop + 7);
    ctx.lineTo(centerX + 4, bodyTop);
    ctx.closePath();
    ctx.fill();

    // ----- DRAW ARMS (depends on state) -----
    this.drawArms(ctx, centerX, bodyTop, f, state);

    // ----- DRAW HEAD -----
    // Skin
    ctx.fillStyle = SKIN;
    ctx.beginPath();
    ctx.arc(headX, headY, headR, 0, Math.PI * 2);
    ctx.fill();

    // Skin shadow (lower half accent)
    ctx.fillStyle = SKIN_DARK;
    ctx.beginPath();
    ctx.arc(headX, headY + 1, headR, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.fill();

    // Eyes
    const eyeOffX = f * 3;
    // Left eye
    ctx.fillStyle = WHITE;
    ctx.fillRect(headX + eyeOffX - 6, headY - 3, 4, 4);
    ctx.fillStyle = EYE_BLACK;
    ctx.fillRect(headX + eyeOffX - 5 + (f > 0 ? 1 : 0), headY - 2, 2, 3);

    // Right eye
    ctx.fillStyle = WHITE;
    ctx.fillRect(headX + eyeOffX + 1, headY - 3, 4, 4);
    ctx.fillStyle = EYE_BLACK;
    ctx.fillRect(headX + eyeOffX + 2 + (f > 0 ? 1 : 0), headY - 2, 2, 3);

    // Mouth (small line)
    if (state === 'charging' || state === 'firing' || state === 'spiritBomb') {
      // Open mouth (yelling)
      ctx.fillStyle = '#D84315';
      ctx.fillRect(headX + eyeOffX - 3, headY + 5, 6, 3);
    } else if (state === 'hit') {
      // Grimace
      ctx.strokeStyle = SKIN_DARK;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(headX + eyeOffX - 3, headY + 6);
      ctx.lineTo(headX + eyeOffX + 3, headY + 5);
      ctx.stroke();
    } else {
      // Neutral / slight smile
      ctx.strokeStyle = SKIN_DARK;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(headX + eyeOffX - 2, headY + 5);
      ctx.quadraticCurveTo(headX + eyeOffX + 1, headY + 8, headX + eyeOffX + 4, headY + 5);
      ctx.stroke();
    }

    // ----- DRAW HAIR (spiky black hair - essential Goku look!) -----
    ctx.fillStyle = HAIR_BLACK;

    // Hair base (covers top of head)
    ctx.beginPath();
    ctx.arc(headX, headY - 1, headR + 2, Math.PI, 2 * Math.PI);
    ctx.fill();

    // Spiky hair - multiple triangular spikes pointing up and to the right (scaled up ~40%)
    // Main center spike (tallest)
    ctx.beginPath();
    ctx.moveTo(headX - 3, headY - headR + 1);
    ctx.lineTo(headX + 1, headY - headR - 17);
    ctx.lineTo(headX + 6, headY - headR + 3);
    ctx.closePath();
    ctx.fill();

    // Right spike (pointing up-right)
    ctx.beginPath();
    ctx.moveTo(headX + 4, headY - headR + 1);
    ctx.lineTo(headX + 11, headY - headR - 13);
    ctx.lineTo(headX + 10, headY - headR + 4);
    ctx.closePath();
    ctx.fill();

    // Far right spike (more to the right)
    ctx.beginPath();
    ctx.moveTo(headX + 8, headY - headR + 4);
    ctx.lineTo(headX + 18, headY - headR - 7);
    ctx.lineTo(headX + 13, headY - headR + 7);
    ctx.closePath();
    ctx.fill();

    // Left spike
    ctx.beginPath();
    ctx.moveTo(headX - 7, headY - headR + 3);
    ctx.lineTo(headX - 6, headY - headR - 11);
    ctx.lineTo(headX - 1, headY - headR + 1);
    ctx.closePath();
    ctx.fill();

    // Far left spike (smaller)
    ctx.beginPath();
    ctx.moveTo(headX - 11, headY - headR + 6);
    ctx.lineTo(headX - 13, headY - headR - 4);
    ctx.lineTo(headX - 6, headY - headR + 3);
    ctx.closePath();
    ctx.fill();

    // Side hair (covers ears area on the side Goku faces away from)
    ctx.beginPath();
    ctx.moveTo(headX - f * 10, headY - 4);
    ctx.lineTo(headX - f * 14, headY - 8);
    ctx.lineTo(headX - f * 13, headY + 1);
    ctx.closePath();
    ctx.fill();

    // Forehead bang spikes (small, pointing forward-down)
    ctx.beginPath();
    ctx.moveTo(headX + f * 4, headY - headR + 3);
    ctx.lineTo(headX + f * 8, headY - 5);
    ctx.lineTo(headX + f * 1, headY - 5);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(headX + f * 1, headY - headR + 1);
    ctx.lineTo(headX + f * 4, headY - 3);
    ctx.lineTo(headX - f * 1, headY - 4);
    ctx.closePath();
    ctx.fill();

    // ----- HEADBAND (optional red headband detail for Goku look) -----
    // Actually Goku doesn't wear a headband in base form - skip this

    // ----- WRISTBANDS -----
    // Drawn in drawArms based on state

    ctx.restore();
  }

  drawArms(ctx, centerX, bodyTop, f, state) {
    const SKIN = '#FFCC80';
    const GI_ORANGE = '#FF6D00';
    const BELT_BLUE = '#1565C0';
    const SKIN_DARK = '#FFB74D';
    const armW = 7;
    const armH = 14;

    switch (state) {
      case 'idle':
      default:
        // Arms at sides, slightly angled
        // Left arm
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX - 14, bodyTop + 3, armW, armH);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX - 14, bodyTop + armH, armW, 6);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(centerX - 14, bodyTop + armH - 2, armW, 3);

        // Right arm
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX + 7, bodyTop + 3, armW, armH);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX + 7, bodyTop + armH, armW, 6);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(centerX + 7, bodyTop + armH - 2, armW, 3);
        break;

      case 'moving':
        // Arms slightly back, showing motion
        // Back arm
        ctx.save();
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX - f * 13, bodyTop + 4, armW, armH - 1);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX - f * 13, bodyTop + armH, armW, 4);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(centerX - f * 13, bodyTop + armH - 2, armW, 3);

        // Front arm (forward)
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX + f * 8, bodyTop + 1, armW, armH - 1);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX + f * 8, bodyTop + armH - 3, armW, 4);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(centerX + f * 8, bodyTop + armH - 4, armW, 3);
        ctx.restore();
        break;

      case 'kiBlast':
        // One arm extended forward, other at side
        // Back arm (at side)
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX - f * 13, bodyTop + 3, armW, armH);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX - f * 13, bodyTop + armH, armW, 6);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(centerX - f * 13, bodyTop + armH - 2, armW, 3);

        // Extended arm (forward, horizontal)
        ctx.fillStyle = GI_ORANGE;
        const extStartX = centerX + f * 7;
        const extY = bodyTop + 5;
        ctx.fillRect(f > 0 ? extStartX : extStartX - 20, extY, 20, armW);
        // Hand / fist at end
        ctx.fillStyle = SKIN;
        ctx.fillRect(f > 0 ? extStartX + 17 : extStartX - 23, extY - 1, 7, armW + 2);
        // Wristband
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(f > 0 ? extStartX + 14 : extStartX - 17, extY, 4, armW);

        // Palm glow for ki
        ctx.fillStyle = 'rgba(255, 255, 100, 0.5)';
        ctx.beginPath();
        ctx.arc(f > 0 ? extStartX + 24 : extStartX - 24, extY + armW / 2, 6, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'melee':
        // Punching forward with fist
        // Back arm tucked
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX - f * 11, bodyTop + 5, armW, armH - 4);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX - f * 11, bodyTop + armH - 1, armW, 4);

        // Punching arm (extended far forward)
        ctx.fillStyle = GI_ORANGE;
        const punchStartX = centerX + f * 7;
        const punchY = bodyTop + 4;
        ctx.fillRect(f > 0 ? punchStartX : punchStartX - 25, punchY, 25, armW);
        // Fist (bigger square for emphasis)
        ctx.fillStyle = SKIN;
        ctx.fillRect(f > 0 ? punchStartX + 22 : punchStartX - 30, punchY - 1, 8, armW + 2);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(f > 0 ? punchStartX + 20 : punchStartX - 24, punchY, 4, armW);

        // Impact lines (small white streaks)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 2;
        const fistTipX = f > 0 ? punchStartX + 30 : punchStartX - 30;
        const fistTipY = punchY + armW / 2;
        for (let i = 0; i < 3; i++) {
          const angle = (i - 1) * 0.3;
          ctx.beginPath();
          ctx.moveTo(fistTipX + f * 4, fistTipY + Math.sin(angle) * 6);
          ctx.lineTo(fistTipX + f * 14, fistTipY + Math.sin(angle) * 11);
          ctx.stroke();
        }
        break;

      case 'charging':
        // Kamehameha pose: both arms pulled back, hands together
        // Both arms pulled to the side (opposite of facing)
        ctx.fillStyle = GI_ORANGE;
        const chargeArmX = centerX - f * 14;
        const chargeArmY = bodyTop + 7;

        // Upper arm going back
        ctx.fillRect(chargeArmX - 4, chargeArmY, 11, armW);
        ctx.fillRect(chargeArmX - 4, chargeArmY + armW, 11, armW);

        // Forearms
        ctx.fillStyle = SKIN;
        ctx.fillRect(chargeArmX - f * 8, chargeArmY + 1, armW, armW);
        ctx.fillRect(chargeArmX - f * 8, chargeArmY + armW, armW, armW);

        // Wristbands
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(chargeArmX - f * 6, chargeArmY + 1, 3, armW);
        ctx.fillRect(chargeArmX - f * 6, chargeArmY + armW, 3, armW);

        // Cupped hands
        ctx.fillStyle = SKIN;
        const handCX = chargeArmX - f * 11;
        const handCY = chargeArmY + armW;
        ctx.beginPath();
        ctx.arc(handCX, handCY, 6, 0, Math.PI * 2);
        ctx.fill();

        // Energy glow between hands (drawn elsewhere in drawFull)
        break;

      case 'firing':
        // Kamehameha firing: arms extended forward together
        ctx.fillStyle = GI_ORANGE;
        const fireStartX = centerX + f * 4;
        const fireY = bodyTop + 5;

        // Two arms side by side, extended forward
        ctx.fillRect(f > 0 ? fireStartX : fireStartX - 22, fireY, 22, armW);
        ctx.fillRect(f > 0 ? fireStartX : fireStartX - 22, fireY + armW + 1, 22, armW);

        // Hands together at end
        ctx.fillStyle = SKIN;
        const handFireX = f > 0 ? fireStartX + 20 : fireStartX - 28;
        ctx.fillRect(handFireX, fireY - 1, 8, armW * 2 + 3);

        // Wristbands
        ctx.fillStyle = BELT_BLUE;
        const wbX = f > 0 ? fireStartX + 17 : fireStartX - 21;
        ctx.fillRect(wbX, fireY, 4, armW);
        ctx.fillRect(wbX, fireY + armW + 1, 4, armW);

        // Bright glow at hands
        ctx.fillStyle = 'rgba(100, 180, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(handFireX + 4, fireY + armW, 11, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(handFireX + 4, fireY + armW, 6, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'spiritBomb':
        // Arms raised above head
        ctx.fillStyle = GI_ORANGE;
        const raiseX1 = centerX - 11;
        const raiseX2 = centerX + 4;
        const raiseY = bodyTop - 17;

        // Left arm raised up
        ctx.fillRect(raiseX1, raiseY, armW, 20);
        ctx.fillStyle = SKIN;
        ctx.fillRect(raiseX1, raiseY - 4, armW, 6);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(raiseX1, raiseY - 1, armW, 3);

        // Right arm raised up
        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(raiseX2, raiseY, armW, 20);
        ctx.fillStyle = SKIN;
        ctx.fillRect(raiseX2, raiseY - 4, armW, 6);
        ctx.fillStyle = BELT_BLUE;
        ctx.fillRect(raiseX2, raiseY - 1, armW, 3);

        // Upward glow
        ctx.fillStyle = 'rgba(200, 220, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(centerX, raiseY - 8, 14, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'hit':
        // Flinching: arms pulled in, body leaning back
        ctx.fillStyle = GI_ORANGE;
        // Both arms close to body, slightly up (defensive flinch)
        ctx.fillRect(centerX - 13, bodyTop + 1, armW, armH - 3);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX - 13, bodyTop - 1, armW, 4);

        ctx.fillStyle = GI_ORANGE;
        ctx.fillRect(centerX + 6, bodyTop + 1, armW, armH - 3);
        ctx.fillStyle = SKIN;
        ctx.fillRect(centerX + 6, bodyTop - 1, armW, 4);

        // Pain indicators (small stars or flashes)
        if (Math.random() > 0.5) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fillRect(centerX + f * 17, bodyTop - 5, 4, 4);
        }
        break;
    }
  }
}

// ---------------------------------------------------------------------------
// Player instance (initialized when game starts)
// ---------------------------------------------------------------------------
let player = null;

// === END PLAYER CHARACTER ===// === ENEMIES AND BOSSES ===

// ---- Enemy Projectile ----
class EnemyProjectile {
  constructor(x, y, vx, vy, color, size, damage) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.color = color || '#FF0000'; this.size = size || 4;
    this.damage = damage || 10; this.alive = true; this.age = 0;
  }
  update(dt) {
    this.age += dt;
    this.x += this.vx * dt; this.y += this.vy * dt;
    if (this.x < -50 || this.x > CANVAS_W + 50 || this.y < -50 || this.y > CANVAS_H + 50) this.alive = false;
    return this.alive;
  }
  draw(ctx) {
    ctx.save();
    // gumdrop shape
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    // shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.arc(this.x - this.size*0.25, this.y - this.size*0.25, this.size * 0.4, 0, Math.PI * 2);
    ctx.fill();
    // sugar sparkle
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(this.x + this.size*0.2, this.y - this.size*0.4, 2, 2);
    ctx.restore();
  }
}

let enemyProjectiles = [];

// ---- Power-Up ----
class PowerUp {
  constructor(x, y, type) {
    this.x = x; this.y = y; this.type = type;
    this.w = 24; this.h = 24; this.alive = true;
    this.bobTimer = Math.random() * Math.PI * 2;
    this.vy = 18;
  }
  update(dt) {
    this.bobTimer += dt * 3;
    this.y += this.vy * dt;
    if (this.y > CANVAS_H + 20) this.alive = false;
    return this.alive;
  }
  draw(ctx) {
    var drawY = this.y + Math.sin(this.bobTimer) * 4;
    ctx.save();
    switch(this.type) {
      case 'senzu':
        // cupcake wrapper (brown)
        ctx.fillStyle = '#AA7744';
        ctx.fillRect(this.x + 4, drawY + 12, 16, 10);
        // cake top (pink frosting)
        ctx.fillStyle = '#FF88AA';
        ctx.beginPath(); ctx.arc(this.x + 12, drawY + 10, 10, Math.PI, 0); ctx.fill();
        // frosting swirl
        ctx.fillStyle = '#FFAACC';
        ctx.beginPath(); ctx.arc(this.x + 12, drawY + 8, 6, Math.PI, 0); ctx.fill();
        // cherry on top
        ctx.fillStyle = '#FF4466';
        ctx.beginPath(); ctx.arc(this.x + 12, drawY + 2, 3, 0, Math.PI * 2); ctx.fill();
        break;
      case 'ki':
        // candy cane stick
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(this.x + 10, drawY + 4, 4, 16);
        // red stripes
        ctx.fillStyle = '#FF4444';
        ctx.fillRect(this.x + 10, drawY + 6, 4, 3);
        ctx.fillRect(this.x + 10, drawY + 12, 4, 3);
        // hook top
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath(); ctx.arc(this.x + 14, drawY + 4, 4, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#FF4444';
        ctx.beginPath(); ctx.arc(this.x + 14, drawY + 4, 4, Math.PI, Math.PI*1.5); ctx.fill();
        break;
      case 'dragonball':
        // golden cookie circle
        ctx.fillStyle = '#FFD700';
        ctx.beginPath(); ctx.arc(this.x + 12, drawY + 12, 10, 0, Math.PI * 2); ctx.fill();
        // darker edge
        ctx.strokeStyle = '#CC9900';
        ctx.lineWidth = 2;
        ctx.stroke();
        // star shape in center
        ctx.fillStyle = '#FFAA00';
        ctx.beginPath();
        for(var s=0; s<5; s++) {
          var a = s * Math.PI * 2/5 - Math.PI/2;
          var r = s===0 ? 0 : 6;
          if(s===0) ctx.moveTo(this.x+12+Math.cos(a)*6, drawY+12+Math.sin(a)*6);
          else ctx.lineTo(this.x+12+Math.cos(a)*6, drawY+12+Math.sin(a)*6);
          var a2 = a + Math.PI/5;
          ctx.lineTo(this.x+12+Math.cos(a2)*3, drawY+12+Math.sin(a2)*3);
        }
        ctx.closePath(); ctx.fill();
        ctx.lineWidth = 1;
        break;
      case 'speed':
        // cotton candy fluffy shape
        ctx.fillStyle = '#FFAADD';
        ctx.beginPath(); ctx.arc(this.x + 12, drawY + 6, 7, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#AADDFF';
        ctx.beginPath(); ctx.arc(this.x + 10, drawY + 10, 6, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#FFCCEE';
        ctx.beginPath(); ctx.arc(this.x + 14, drawY + 9, 5, 0, Math.PI * 2); ctx.fill();
        // stick
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(this.x + 11, drawY + 14, 3, 10);
        break;
    }
    ctx.restore();
  }
}

let powerUps = [];

// Floating text labels (damage numbers, powerup names)
var floatingTexts = [];

function spawnFloatingText(x, y, text, color, size) {
  floatingTexts.push({
    x: x, y: y, text: text, color: color || '#FFFFFF',
    size: size || 2, life: 1.2, maxLife: 1.2, vy: -60
  });
}

function updateFloatingTexts(dt) {
  for (var i = floatingTexts.length - 1; i >= 0; i--) {
    var ft = floatingTexts[i];
    ft.life -= dt;
    ft.y += ft.vy * dt;
    ft.vy *= 0.97;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
}

function drawFloatingTexts(ctx) {
  for (var i = 0; i < floatingTexts.length; i++) {
    var ft = floatingTexts[i];
    var alpha = Math.min(1, ft.life / 0.3);
    ctx.save();
    ctx.globalAlpha = alpha;
    drawPixelTextCenteredWithShadow(ctx, ft.text, ft.x - camera.x, ft.y, ft.size, ft.color);
    ctx.restore();
  }
}

function maybeDropPowerUp(x, y) {
  var roll = Math.random();
  if (roll < 0.12) powerUps.push(new PowerUp(x, y, 'senzu'));
  else if (roll < 0.25) powerUps.push(new PowerUp(x, y, 'ki'));
  else if (roll < 0.30) powerUps.push(new PowerUp(x, y, 'dragonball'));
  else if (roll < 0.35) powerUps.push(new PowerUp(x, y, 'speed'));
}

// ---- Base Enemy ----
class Enemy {
  constructor(x, y, w, h, hp, speed, score) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.hp = hp; this.maxHp = hp; this.speed = speed;
    this.scoreValue = score; this.alive = true;
    this.flashTimer = 0; this.age = 0;
  }
  update(dt) { this.age += dt; this.flashTimer = Math.max(0, this.flashTimer - dt); }
  draw(ctx) {}
  takeDamage(amount) {
    this.hp -= amount; this.flashTimer = 0.1;
    if (this.hp <= 0) { this.die(); }
  }
  die() {
    this.alive = false;
    spawnExplosion(this.x + this.w/2, this.y + this.h/2, 2);
    playSound('explosion');
    if (player) {
      player.score += this.scoreValue;
      player.ki = Math.min(player.maxKi, player.ki + 3);
    }
    maybeDropPowerUp(this.x + this.w/2, this.y + this.h/2);
  }
  drawHealthBar(ctx) {
    if (this.hp >= this.maxHp) return;
    var bw = this.w + 4; var bh = 5;
    var bx = this.x - 2; var by = this.y - 8;
    // Background with rounded ends
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.arc(bx + bh / 2, by + bh / 2, bh / 2, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(bx + bw - bh / 2, by + bh / 2, bh / 2, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath(); ctx.fill();
    // Fill
    var pct = Math.max(0, this.hp / this.maxHp);
    var fillW = bw * pct;
    if (fillW > bh) {
      ctx.fillStyle = pct > 0.5 ? '#44DD66' : pct > 0.25 ? '#FFCC22' : '#FF4466';
      ctx.beginPath();
      ctx.arc(bx + bh / 2, by + bh / 2, bh / 2, Math.PI * 0.5, Math.PI * 1.5);
      ctx.arc(bx + fillW - bh / 2, by + bh / 2, bh / 2, Math.PI * 1.5, Math.PI * 0.5);
      ctx.closePath(); ctx.fill();
    }
  }
}

let enemies = [];

// ---- LEVEL 1 ENEMIES ----

class RedRibbonSoldier extends Enemy {
  constructor(x, y) {
    super(x, y, 28, 36, 20, 50, 50);
    this.shootTimer = 1 + Math.random();
    this.shootInterval = 2;
    this.dir = -1;
  }
  update(dt) {
    super.update(dt);
    this.x += this.dir * this.speed * dt;
    this.shootTimer -= dt;
    if (this.shootTimer <= 0) {
      this.shootTimer = this.shootInterval;
      enemyProjectiles.push(new EnemyProjectile(this.x, this.y + 10, -80, 0, '#FF88CC', 3, 5));
      playSound('kiBlast');
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    // Gingerbread body
    ctx.fillStyle = fc || '#CC8844';
    ctx.fillRect(this.x + 2, this.y + 8, 16, 22);
    // Gingerbread head (circle)
    ctx.fillStyle = fc || '#CC8844';
    ctx.beginPath(); ctx.arc(this.x + 10, this.y + 5, 9, 0, Math.PI*2); ctx.fill();
    // Arms
    ctx.fillStyle = fc || '#CC8844';
    ctx.fillRect(this.x - 4, this.y + 12, 6, 4);
    ctx.fillRect(this.x + 18, this.y + 12, 6, 4);
    // Legs
    ctx.fillRect(this.x + 2, this.y + 28, 5, 6);
    ctx.fillRect(this.x + 13, this.y + 28, 5, 6);
    // White icing buttons
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(this.x + 8, this.y + 13, 4, 3);
    ctx.fillRect(this.x + 8, this.y + 19, 4, 3);
    ctx.fillRect(this.x + 8, this.y + 25, 4, 3);
    // Icing smile
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(this.x + 6, this.y + 7, 8, 2);
    // Icing eyes
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(this.x + 7, this.y + 3, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(this.x + 13, this.y + 3, 2, 0, Math.PI*2); ctx.fill();
    // Black pupils
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x + 6, this.y + 2, 2, 2);
    ctx.fillRect(this.x + 12, this.y + 2, 2, 2);
    this.drawHealthBar(ctx);
  }
}

class BattleRobot extends Enemy {
  constructor(x, y) {
    super(x, y, 32, 32, 40, 70, 100);
    this.baseY = y; this.sineOffset = Math.random() * Math.PI * 2;
    this.shootTimer = 1.5 + Math.random();
  }
  update(dt) {
    super.update(dt);
    this.x -= this.speed * dt;
    this.y = this.baseY + Math.sin(this.age * 2 + this.sineOffset) * 40;
    this.shootTimer -= dt;
    if (this.shootTimer <= 0) {
      this.shootTimer = 2;
      enemyProjectiles.push(new EnemyProjectile(this.x + 16, this.y + 32, 0, 70, '#88DDFF', 4, 6));
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 16; var cy = this.y + 16;
    // Donut body (outer ring)
    ctx.fillStyle = fc || '#FFAA77';
    ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.fill();
    // Donut hole
    ctx.fillStyle = '#FFD4E8';
    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fill();
    // Pink glaze on top
    ctx.fillStyle = fc || '#FF88BB';
    ctx.beginPath(); ctx.arc(cx, cy - 2, 13, Math.PI, Math.PI * 2); ctx.fill();
    // Sprinkles
    ctx.fillStyle = '#FF4444'; ctx.fillRect(cx - 8, cy - 8, 3, 2);
    ctx.fillStyle = '#44FF44'; ctx.fillRect(cx + 3, cy - 10, 3, 2);
    ctx.fillStyle = '#4444FF'; ctx.fillRect(cx - 5, cy - 11, 2, 3);
    ctx.fillStyle = '#FFFF44'; ctx.fillRect(cx + 6, cy - 7, 2, 3);
    ctx.fillStyle = '#FF44FF'; ctx.fillRect(cx - 1, cy - 12, 3, 2);
    // Cute eyes on the donut
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(cx - 4, cy + 2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, cy + 2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 4, cy + 2, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, cy + 2, 1.5, 0, Math.PI * 2); ctx.fill();
    this.drawHealthBar(ctx);
  }
}

class NinjaAssassin extends Enemy {
  constructor(x, y) {
    super(x, y, 26, 34, 15, 160, 75);
    this.attackCooldown = 0;
  }
  update(dt) {
    super.update(dt);
    if (player) {
      var dx = player.x - this.x; var dy = player.y - this.y;
      var dist = Math.sqrt(dx*dx + dy*dy) || 1;
      this.x += (dx/dist) * this.speed * dt;
      this.y += (dy/dist) * this.speed * dt * 0.5;
    } else {
      this.x -= this.speed * dt;
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    // Jellybean body (oval)
    ctx.fillStyle = fc || '#FF6688';
    ctx.beginPath(); ctx.ellipse(this.x + 13, this.y + 17, 12, 16, 0, 0, Math.PI * 2); ctx.fill();
    // Shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath(); ctx.ellipse(this.x + 9, this.y + 11, 4, 7, -0.3, 0, Math.PI * 2); ctx.fill();
    // Cute eyes (white)
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(this.x + 9, this.y + 14, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(this.x + 17, this.y + 14, 3, 0, Math.PI * 2); ctx.fill();
    // Black pupils
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(this.x + 10, this.y + 14, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(this.x + 18, this.y + 14, 1.5, 0, Math.PI * 2); ctx.fill();
    // Little smile
    ctx.strokeStyle = '#CC3355';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(this.x + 13, this.y + 18, 4, 0.2, Math.PI - 0.2); ctx.stroke();
    // Little feet
    ctx.fillStyle = fc || '#FF6688';
    ctx.beginPath(); ctx.ellipse(this.x + 8, this.y + 31, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(this.x + 18, this.y + 31, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
    this.drawHealthBar(ctx);
  }
}

// ---- LEVEL 2 ENEMIES ----

class FriezaSoldier extends Enemy {
  constructor(x, y) {
    super(x, y, 30, 34, 35, 70, 100);
    this.shootTimer = 1 + Math.random() * 2;
  }
  update(dt) {
    super.update(dt);
    this.x -= this.speed * dt;
    this.y += Math.sin(this.age * 1.5) * 0.8;
    this.shootTimer -= dt;
    if (this.shootTimer <= 0 && player) {
      this.shootTimer = 2 + Math.random();
      var dx = player.x - this.x; var dy = player.y - this.y;
      var dist = Math.sqrt(dx*dx+dy*dy) || 1;
      enemyProjectiles.push(new EnemyProjectile(this.x, this.y+17, (dx/dist)*100, (dy/dist)*100, '#FFCC44', 4, 7));
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 15;
    // Candy corn triangle - yellow base
    ctx.fillStyle = fc || '#FFEE44';
    ctx.beginPath();
    ctx.moveTo(cx - 14, this.y + 34);
    ctx.lineTo(cx + 14, this.y + 34);
    ctx.lineTo(cx, this.y);
    ctx.closePath(); ctx.fill();
    // Orange middle band
    ctx.fillStyle = fc || '#FF8822';
    ctx.beginPath();
    ctx.moveTo(cx - 10, this.y + 24);
    ctx.lineTo(cx + 10, this.y + 24);
    ctx.lineTo(cx + 5, this.y + 12);
    ctx.lineTo(cx - 5, this.y + 12);
    ctx.closePath(); ctx.fill();
    // White tip at top
    ctx.fillStyle = fc || '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(cx - 5, this.y + 12);
    ctx.lineTo(cx + 5, this.y + 12);
    ctx.lineTo(cx, this.y);
    ctx.closePath(); ctx.fill();
    // Small dot eyes
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 4, this.y + 20, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, this.y + 20, 2, 0, Math.PI * 2); ctx.fill();
    // Cute little smile
    ctx.strokeStyle = '#AA5500';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, this.y + 24, 3, 0.2, Math.PI - 0.2); ctx.stroke();
    this.drawHealthBar(ctx);
  }
}

class BruteWarrior extends Enemy {
  constructor(x, y) {
    super(x, y, 40, 44, 80, 120, 150);
    this.charging = false; this.chargeTimer = 2;
  }
  update(dt) {
    super.update(dt);
    this.chargeTimer -= dt;
    if (this.chargeTimer <= 0 && !this.charging) {
      this.charging = true; this.speed = 280;
    }
    if (this.charging) {
      this.x -= this.speed * dt;
    } else {
      this.x -= 30 * dt;
    }
    if (this.x < -50) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 20; var cy = this.y + 22;
    // Large chocolate ball body
    ctx.fillStyle = fc || '#664422';
    ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.fill();
    // Lighter chocolate highlight
    ctx.fillStyle = fc || '#886644';
    ctx.beginPath(); ctx.arc(cx - 5, cy - 6, 10, 0, Math.PI * 2); ctx.fill();
    // Cocoa dust specks
    ctx.fillStyle = '#AA8866';
    ctx.fillRect(cx - 10, cy - 12, 2, 2);
    ctx.fillRect(cx + 6, cy - 10, 2, 2);
    ctx.fillRect(cx - 3, cy - 14, 2, 2);
    ctx.fillRect(cx + 10, cy - 6, 2, 2);
    ctx.fillRect(cx - 12, cy - 4, 2, 2);
    // Angry cute face - eyes
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(cx - 6, cy - 2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 6, cy - 2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 5, cy - 1, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 7, cy - 1, 2, 0, Math.PI * 2); ctx.fill();
    // Angry eyebrows
    ctx.strokeStyle = '#442200';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx - 10, cy - 7); ctx.lineTo(cx - 3, cy - 5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 10, cy - 7); ctx.lineTo(cx + 3, cy - 5); ctx.stroke();
    // Grumpy mouth
    ctx.strokeStyle = '#442200';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, cy + 6, 4, Math.PI + 0.3, -0.3); ctx.stroke();
    this.drawHealthBar(ctx);
  }
}

class GinyuStriker extends Enemy {
  constructor(x, y) {
    super(x, y, 28, 34, 30, 100, 125);
    this.pattern = Math.floor(Math.random() * 3);
    this.patternTimer = 0;
    this.bodyColor = ['#FF4488', '#44CCFF', '#88FF44'][this.pattern];
  }
  update(dt) {
    super.update(dt);
    this.patternTimer += dt;
    this.x -= this.speed * dt;
    // diagonal attack patterns
    if (this.pattern === 0) this.y += Math.sin(this.patternTimer * 4) * 3;
    else if (this.pattern === 1) this.y -= Math.cos(this.patternTimer * 3) * 2;
    else this.y += Math.cos(this.patternTimer * 5) * 4;
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 14; var cy = this.y + 12;
    // Lollipop stick (white)
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(cx - 2, cy + 6, 4, 18);
    // Circular candy top
    ctx.fillStyle = fc || this.bodyColor;
    ctx.beginPath(); ctx.arc(cx, cy, 12, 0, Math.PI * 2); ctx.fill();
    // White swirl stripe
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 1.5); ctx.stroke();
    ctx.beginPath();
    ctx.arc(cx, cy, 8, Math.PI * 0.5, Math.PI * 2); ctx.stroke();
    // Cute face on candy
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(cx - 4, cy - 2, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, cy - 2, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx - 4, cy - 2, 1.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 4, cy - 2, 1.2, 0, Math.PI * 2); ctx.fill();
    // Happy mouth
    ctx.strokeStyle = '#AA2255';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, cy + 3, 3, 0.2, Math.PI - 0.2); ctx.stroke();
    this.drawHealthBar(ctx);
  }
}

// ---- LEVEL 3 ENEMIES ----

class CellJunior extends Enemy {
  constructor(x, y) {
    super(x, y, 26, 30, 50, 120, 150);
    this.attackMode = 'ki'; this.switchTimer = 1.5;
    this.shootTimer = 0.8;
  }
  update(dt) {
    super.update(dt);
    this.switchTimer -= dt;
    if (this.switchTimer <= 0) {
      this.attackMode = this.attackMode === 'ki' ? 'dive' : 'ki';
      this.switchTimer = 2 + Math.random();
    }
    if (this.attackMode === 'dive' && player) {
      var dx = player.x - this.x; var dy = player.y - this.y;
      var dist = Math.sqrt(dx*dx+dy*dy) || 1;
      this.x += (dx/dist) * this.speed * 1.5 * dt;
      this.y += (dy/dist) * this.speed * 1.5 * dt;
    } else {
      this.x -= this.speed * dt * 0.5;
      this.shootTimer -= dt;
      if (this.shootTimer <= 0 && player) {
        this.shootTimer = 1;
        var dx = player.x - this.x; var dy = player.y - this.y;
        var dist = Math.sqrt(dx*dx+dy*dy) || 1;
        enemyProjectiles.push(new EnemyProjectile(this.x, this.y+11, (dx/dist)*110, (dy/dist)*110, '#88FF88', 4, 8));
      }
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 13; var cy = this.y + 16;
    // Gummy bear body (rounded oval)
    ctx.fillStyle = fc || '#44DD66';
    ctx.beginPath(); ctx.ellipse(cx, cy, 11, 14, 0, 0, Math.PI * 2); ctx.fill();
    // Round ears on top
    ctx.fillStyle = fc || '#44DD66';
    ctx.beginPath(); ctx.arc(cx - 7, this.y + 3, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 7, this.y + 3, 5, 0, Math.PI * 2); ctx.fill();
    // Head
    ctx.beginPath(); ctx.arc(cx, this.y + 8, 8, 0, Math.PI * 2); ctx.fill();
    // Lighter belly patch
    ctx.fillStyle = fc || '#88FFAA';
    ctx.beginPath(); ctx.ellipse(cx, cy + 3, 6, 7, 0, 0, Math.PI * 2); ctx.fill();
    // Sour face - squinting eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(cx - 5, this.y + 6, 4, 2);
    ctx.fillRect(cx + 1, this.y + 6, 4, 2);
    // Puckered mouth (sour!)
    ctx.strokeStyle = '#228833';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, this.y + 11, 2.5, 0, Math.PI * 2); ctx.stroke();
    // Little arms
    ctx.fillStyle = fc || '#44DD66';
    ctx.beginPath(); ctx.ellipse(this.x + 1, cy - 2, 4, 3, -0.4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(this.x + 25, cy - 2, 4, 3, 0.4, 0, Math.PI * 2); ctx.fill();
    // Little feet
    ctx.beginPath(); ctx.ellipse(cx - 5, this.y + 29, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx + 5, this.y + 29, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
    // Sugar coating sparkles
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(cx - 8, cy - 5, 2, 2);
    ctx.fillRect(cx + 5, cy - 8, 2, 2);
    ctx.fillRect(cx - 3, cy + 6, 2, 2);
    this.drawHealthBar(ctx);
  }
}

class DarkClone extends Enemy {
  constructor(x, y) {
    super(x, y, 32, 38, 60, 70, 200);
    this.shootTimer = 1.5;
  }
  update(dt) {
    super.update(dt);
    this.x -= this.speed * dt * 0.3;
    // Mirror player Y
    if (player) {
      this.y = lerp(this.y, player.y, 0.02);
    }
    this.shootTimer -= dt;
    if (this.shootTimer <= 0) {
      this.shootTimer = 1.5 + Math.random() * 0.5;
      enemyProjectiles.push(new EnemyProjectile(this.x, this.y+19, -120, 0, '#FFAA44', 5, 8));
      enemyProjectiles.push(new EnemyProjectile(this.x, this.y+19, -110, -40, '#FFAA44', 4, 7));
      enemyProjectiles.push(new EnemyProjectile(this.x, this.y+19, -110, 40, '#FFAA44', 4, 7));
    }
    if (this.x < -40) this.alive = false;
  }
  draw(ctx) {
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var cx = this.x + 16; var cy = this.y + 19;
    ctx.save();
    ctx.globalAlpha = 0.85;
    // Dark cookie body (large circle)
    ctx.fillStyle = fc || '#553322';
    ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI * 2); ctx.fill();
    // Cookie edge detail (slightly lighter)
    ctx.strokeStyle = '#664433';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.stroke();
    // Spiky hair silhouette on top (shadow cookie crumbles)
    ctx.fillStyle = fc || '#553322';
    ctx.beginPath();
    ctx.moveTo(cx - 8, this.y + 6); ctx.lineTo(cx - 12, this.y - 4); ctx.lineTo(cx - 3, this.y + 3);
    ctx.moveTo(cx - 3, this.y + 3); ctx.lineTo(cx, this.y - 8); ctx.lineTo(cx + 4, this.y + 3);
    ctx.moveTo(cx + 4, this.y + 3); ctx.lineTo(cx + 8, this.y - 4); ctx.lineTo(cx + 10, this.y + 5);
    ctx.moveTo(cx + 9, this.y + 5); ctx.lineTo(cx + 14, this.y); ctx.lineTo(cx + 13, this.y + 7);
    ctx.fill();
    // Golden glow around cookie
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#FFAA44';
    ctx.beginPath(); ctx.arc(cx, cy, 22, 0, Math.PI * 2); ctx.fill();
    // Chocolate chip spots
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#332211';
    ctx.beginPath(); ctx.arc(cx - 6, cy - 4, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 5, cy - 2, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - 2, cy + 5, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 7, cy + 5, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - 8, cy + 3, 2, 0, Math.PI * 2); ctx.fill();
    // Cookie chip eyes (lighter, glowing)
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#FFCC66';
    ctx.beginPath(); ctx.arc(cx - 5, cy - 6, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 5, cy - 6, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#FFE888';
    ctx.beginPath(); ctx.arc(cx - 5, cy - 6, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 5, cy - 6, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    this.drawHealthBar(ctx);
  }
}

class BuuBlob extends Enemy {
  constructor(x, y, size) {
    var sz = size || 1;
    var w = Math.floor(24 * sz); var h = Math.floor(24 * sz);
    super(x, y, w, h, Math.floor(70 * sz), 70, Math.floor(175 * sz));
    this.blobSize = sz; this.wobble = Math.random() * Math.PI * 2;
  }
  update(dt) {
    super.update(dt);
    this.wobble += dt * 3;
    this.x -= this.speed * dt;
    this.y += Math.sin(this.wobble) * 1.5;
    if (this.x < -40) this.alive = false;
  }
  die() {
    this.alive = false;
    spawnExplosion(this.x + this.w/2, this.y + this.h/2, 1.5);
    playSound('explosion');
    if (player) player.score += this.scoreValue;
    // split into 2 smaller blobs
    if (this.blobSize > 0.4) {
      var newSize = this.blobSize * 0.6;
      enemies.push(new BuuBlob(this.x - 10, this.y - 10, newSize));
      enemies.push(new BuuBlob(this.x + 10, this.y + 10, newSize));
    } else {
      maybeDropPowerUp(this.x + this.w/2, this.y + this.h/2);
    }
  }
  draw(ctx) {
    var cx = this.x + this.w/2; var cy = this.y + this.h/2;
    var r = this.w / 2;
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    // Main bubblegum body (bright pink)
    ctx.fillStyle = fc || '#FF88CC';
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
    // Wobble bumps (lighter pink)
    ctx.fillStyle = fc || '#FFAADD';
    ctx.beginPath(); ctx.arc(cx - r*0.4, cy - r*0.3, r*0.4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + r*0.3, cy + r*0.2, r*0.35, 0, Math.PI * 2); ctx.fill();
    // Shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath(); ctx.arc(cx - r*0.3, cy - r*0.3, r*0.3, 0, Math.PI * 2); ctx.fill();
    // Happy eyes
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(cx - r*0.25, cy - r*0.15, r*0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + r*0.25, cy - r*0.15, r*0.2, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(cx - r*0.2, cy - r*0.1, r*0.1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + r*0.3, cy - r*0.1, r*0.1, 0, Math.PI * 2); ctx.fill();
    // Cute smiley mouth
    ctx.strokeStyle = '#DD4488';
    ctx.lineWidth = Math.max(1.5, r * 0.1);
    ctx.beginPath(); ctx.arc(cx, cy + r*0.15, r*0.25, 0.2, Math.PI - 0.2); ctx.stroke();
    // Bubblegum stretch antenna
    ctx.strokeStyle = fc || '#FF88CC';
    ctx.lineWidth = Math.max(2, r * 0.15);
    ctx.beginPath(); ctx.moveTo(cx, cy - r); ctx.quadraticCurveTo(cx + r*0.8, cy - r - r*0.8, cx + r*0.4, cy - r - r*0.5); ctx.stroke();
    // Bubble at end of antenna
    ctx.fillStyle = fc || '#FFAADD';
    ctx.beginPath(); ctx.arc(cx + r*0.4, cy - r - r*0.5, r*0.2, 0, Math.PI * 2); ctx.fill();
    this.drawHealthBar(ctx);
  }
}

// ===========================================================
// BOSSES
// ===========================================================

class Boss {
  constructor(x, y, w, h, hp, name) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.hp = hp; this.maxHp = hp; this.name = name;
    this.alive = true; this.phase = 1; this.flashTimer = 0;
    this.attackTimer = 0; this.currentAttack = null;
    this.attackDuration = 0; this.vulnerable = false;
    this.vulnerableTimer = 0; this.enteringScene = true;
    this.enterTarget = CANVAS_W - this.w - 40;
    this.age = 0; this.defeated = false;
    this.deathTimer = 0; this.deathDuration = 3;
    this.telegraphTimer = 0;
  }
  update(dt) {
    this.age += dt;
    this.flashTimer = Math.max(0, this.flashTimer - dt);
    this.telegraphTimer = Math.max(0, this.telegraphTimer - dt);
    if (this.defeated) {
      this.deathTimer += dt;
      if (this.deathTimer < this.deathDuration) {
        if (Math.random() < 0.3) {
          spawnExplosion(this.x + rand(0, this.w), this.y + rand(0, this.h), 2);
          shakeScreen(3);
        }
      }
      if (this.deathTimer >= this.deathDuration) { this.alive = false; }
      return;
    }
    if (this.enteringScene) {
      this.x = lerp(this.x, this.enterTarget, 0.03);
      if (Math.abs(this.x - this.enterTarget) < 2) { this.enteringScene = false; }
      return;
    }
    if (this.vulnerableTimer > 0) {
      this.vulnerableTimer -= dt; this.vulnerable = true;
      if (this.vulnerableTimer <= 0) this.vulnerable = false;
    }
  }
  takeDamage(amount) {
    this.hp -= amount; this.flashTimer = 0.08;
    if (this.hp <= 0 && !this.defeated) {
      this.defeated = true;
      playSound('explosion');
      flash('#FFFFFF', 0.5);
      shakeScreen(15);
      if (player) player.score += 1000 * this.phase;
    }
  }
  draw(ctx) {}
  drawBossBar(ctx) {
    var bw = 460; var bh = 18;
    var bx = (CANVAS_W - bw) / 2; var by = 8;

    // Panel background
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = 'rgba(60, 10, 30, 0.7)';
    drawRoundedRect(ctx, bx - 10, by - 10, bw + 20, bh + 30, 10);
    ctx.fill();
    ctx.restore();

    // Boss name
    drawPixelTextCenteredWithShadow(ctx, this.name, CANVAS_W/2, by - 4, 2, '#FFFFFF', '#442233');
    by += 16;

    // Bar background
    ctx.fillStyle = 'rgba(100, 0, 30, 0.8)';
    drawRoundedRect(ctx, bx, by, bw, bh, 4);
    ctx.fill();

    // HP fill with gradient
    var pct = Math.max(0, this.hp / this.maxHp);
    var bossGrad = ctx.createLinearGradient(bx, by, bx, by + bh);
    bossGrad.addColorStop(0, '#FF6688');
    bossGrad.addColorStop(0.5, '#FF4466');
    bossGrad.addColorStop(1, '#CC2244');
    ctx.fillStyle = bossGrad;
    drawRoundedRect(ctx, bx, by, bw * pct, bh, 4);
    ctx.fill();

    // Shimmer effect
    ctx.save();
    ctx.globalAlpha = 0.2 + Math.sin(gameAge * 4) * 0.1;
    ctx.fillStyle = '#FFAACC';
    drawRoundedRect(ctx, bx, by, bw * pct * 0.6, bh * 0.4, 2);
    ctx.fill();
    ctx.restore();

    // Border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 1.5;
    drawRoundedRect(ctx, bx, by, bw, bh, 4);
    ctx.stroke();

    // Phase indicator dots
    if (this.phase > 1) {
      for (var i = 0; i < this.phase; i++) {
        ctx.fillStyle = '#FFD700';
        ctx.beginPath(); ctx.arc(bx + bw + 14 + i * 12, by + bh / 2, 4, 0, Math.PI * 2); ctx.fill();
      }
    }
  }
  telegraph() { this.telegraphTimer = 0.4; }
}

let bosses = [];

// ---- LEVEL 1 BOSS: Giant Mech Robot ----
class GiantMechRobot extends Boss {
  constructor() {
    super(CANVAS_W + 50, CANVAS_H/2 - 64, 96, 128, 300, 'CUPCAKE KING');
    this.attackPattern = 0; this.attacks = ['rockets', 'laser', 'groundPound'];
    this.attackCooldown = 2; this.laserY = 0; this.laserDir = 1;
    this.poundState = 0; this.poundY = 0;
  }
  update(dt) {
    super.update(dt);
    if (this.defeated || this.enteringScene) return;
    this.attackCooldown -= dt;
    if (this.attackCooldown <= 0 && !this.currentAttack) {
      this.currentAttack = this.attacks[this.attackPattern % 3];
      this.attackPattern++;
      this.attackDuration = 0;
      this.telegraph();
    }
    if (this.currentAttack) {
      this.attackDuration += dt;
      switch(this.currentAttack) {
        case 'rockets':
          if (this.attackDuration > 0.4 && this.attackDuration < 0.6) {
            for (var i = 0; i < 5; i++) {
              enemyProjectiles.push(new EnemyProjectile(
                this.x, this.y + 20 + i * 20,
                -100 - Math.random()*30, (i-2)*20 + rand(-10,10),
                '#FF88AA', 5, 8
              ));
            }
            playSound('kiBlast');
            this.attackDuration = 0.7;
          }
          if (this.attackDuration > 2) {
            this.currentAttack = null; this.attackCooldown = 1.5;
            this.vulnerableTimer = 1.5;
          }
          break;
        case 'laser':
          if (this.attackDuration < 0.5) {
            // charge up telegraph
          } else if (this.attackDuration < 2.5) {
            this.laserY += this.laserDir * 80 * dt;
            if (this.laserY > 100) this.laserDir = -1;
            if (this.laserY < -100) this.laserDir = 1;
            // laser hitbox
            var laserBox = {x: 0, y: this.y + 50 + this.laserY, w: this.x + 20, h: 8};
            if (player && !player.invincible && aabb(laserBox, player)) {
              player.takeDamage(2);
            }
          }
          if (this.attackDuration > 3) {
            this.currentAttack = null; this.attackCooldown = 1.5;
            this.vulnerableTimer = 1.5;
          }
          break;
        case 'groundPound':
          if (this.poundState === 0 && this.attackDuration > 0.5) {
            this.poundY = -80; this.poundState = 1;
          }
          if (this.poundState === 1) {
            this.poundY += 300 * dt;
            if (this.poundY >= 0) {
              this.poundY = 0; this.poundState = 2;
              shakeScreen(10); playSound('explosion');
              // shockwave
              for (var i = 0; i < 8; i++) {
                enemyProjectiles.push(new EnemyProjectile(
                  this.x + 48, this.y + this.h,
                  -60 - i * 15, -40 - Math.random()*20,
                  '#FF88CC', 6, 7
                ));
              }
            }
          }
          if (this.attackDuration > 2.5) {
            this.currentAttack = null; this.attackCooldown = 2;
            this.vulnerableTimer = 1.5; this.poundState = 0;
          }
          break;
      }
    }
    // bob
    this.y = CANVAS_H/2 - 64 + Math.sin(this.age * 0.8) * 15 + this.poundY;
  }
  draw(ctx) {
    if (!this.alive) return;
    var x = this.x, y = this.y;
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    // cupcake wrapper (bottom) - trapezoid
    ctx.fillStyle = fc || '#CC8866';
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 100); ctx.lineTo(x + 80, y + 100);
    ctx.lineTo(x + 74, y + 128); ctx.lineTo(x + 22, y + 128);
    ctx.closePath(); ctx.fill();
    // wrapper ridges
    ctx.strokeStyle = fc || '#AA6644';
    ctx.lineWidth = 1;
    for (var i = 0; i < 6; i++) {
      var rx = x + 24 + i * 9;
      ctx.beginPath(); ctx.moveTo(rx, y + 100); ctx.lineTo(rx - 1, y + 128); ctx.stroke();
    }
    // cake body (middle) - rounded rectangle
    ctx.fillStyle = fc || '#FFCCAA';
    ctx.beginPath();
    ctx.moveTo(x + 18, y + 60); ctx.lineTo(x + 78, y + 60);
    ctx.quadraticCurveTo(x + 84, y + 60, x + 84, y + 66);
    ctx.lineTo(x + 84, y + 94);
    ctx.quadraticCurveTo(x + 84, y + 100, x + 78, y + 100);
    ctx.lineTo(x + 18, y + 100);
    ctx.quadraticCurveTo(x + 12, y + 100, x + 12, y + 94);
    ctx.lineTo(x + 12, y + 66);
    ctx.quadraticCurveTo(x + 12, y + 60, x + 18, y + 60);
    ctx.closePath(); ctx.fill();
    // frosting top - big pink dome
    ctx.fillStyle = fc || '#FF88BB';
    ctx.beginPath();
    ctx.arc(x + 48, y + 40, 38, Math.PI, 0);
    ctx.lineTo(x + 86, y + 60); ctx.lineTo(x + 10, y + 60);
    ctx.closePath(); ctx.fill();
    // frosting swirls
    ctx.fillStyle = fc || '#FFAACC';
    ctx.beginPath(); ctx.arc(x + 30, y + 32, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 48, y + 22, 9, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 66, y + 32, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 40, y + 42, 7, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 56, y + 42, 7, 0, Math.PI * 2); ctx.fill();
    // sprinkle decorations on frosting
    var sprinkleColors = ['#FF4444', '#44FF44', '#4444FF', '#FFFF44', '#FF44FF'];
    for (var i = 0; i < 12; i++) {
      ctx.fillStyle = fc || sprinkleColors[i % sprinkleColors.length];
      var sx = x + 20 + Math.sin(i * 2.3) * 24;
      var sy = y + 25 + Math.cos(i * 1.7) * 12;
      ctx.save(); ctx.translate(sx, sy); ctx.rotate(i * 0.8);
      ctx.fillRect(-3, -1, 6, 2);
      ctx.restore();
    }
    // cherry on top (the "core" weak point)
    if (this.vulnerable) {
      ctx.fillStyle = '#FF4466';
      ctx.globalAlpha = 0.5 + Math.sin(this.age * 10) * 0.3;
      ctx.beginPath(); ctx.arc(x + 48, y + 10, 14, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
    }
    ctx.fillStyle = fc || '#FF4466';
    ctx.beginPath(); ctx.arc(x + 48, y + 10, 10, 0, Math.PI * 2); ctx.fill();
    // cherry highlight
    ctx.fillStyle = '#FF8888';
    ctx.beginPath(); ctx.arc(x + 45, y + 7, 3, 0, Math.PI * 2); ctx.fill();
    // cherry stem
    ctx.strokeStyle = fc || '#44AA22';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x + 48, y + 2); ctx.quadraticCurveTo(x + 52, y - 8, x + 48, y - 10); ctx.stroke();
    ctx.lineWidth = 1;
    // candy eyes on frosting
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(x + 38, y + 52, 7, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 58, y + 52, 7, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#222222';
    ctx.beginPath(); ctx.arc(x + 36, y + 53, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 56, y + 53, 3, 0, Math.PI * 2); ctx.fill();
    // cookie stick arms (brown rectangles)
    ctx.fillStyle = fc || '#AA7744';
    ctx.fillRect(x - 4, y + 65, 18, 8);
    ctx.fillRect(x + 82, y + 65, 18, 8);
    ctx.fillStyle = fc || '#CC9966';
    ctx.fillRect(x - 12, y + 60, 14, 18);
    ctx.fillRect(x + 94, y + 60, 14, 18);
    // laser effect (pink frosting beam)
    if (this.currentAttack === 'laser' && this.attackDuration >= 0.5 && this.attackDuration < 2.5) {
      var ly = y + 55 + this.laserY;
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#FF88CC';
      ctx.fillRect(0, ly - 6, x + 20, 12);
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#FFAADD';
      ctx.fillRect(0, ly - 3, x + 20, 6);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, ly - 1, x + 20, 2);
      ctx.restore();
    }
    // telegraph flash
    if (this.telegraphTimer > 0) {
      ctx.save(); ctx.globalAlpha = this.telegraphTimer;
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, this.w, this.h);
      ctx.restore();
    }
    this.drawBossBar(ctx);
  }
}

// ---- LEVEL 2 BOSS: Alien Tyrant ----
class AlienTyrant extends Boss {
  constructor() {
    super(CANVAS_W + 50, CANVAS_H/2 - 80, 128, 160, 500, 'CANDY DRAGON');
    this.attackPattern = 0;
    this.attacks = ['deathBeam', 'tailWhip', 'supernova'];
    this.attackCooldown = 2.5;
    this.transformed = false;
    this.supernovaCharge = null;
  }
  update(dt) {
    super.update(dt);
    if (this.defeated || this.enteringScene) return;
    // phase transition
    if (!this.transformed && this.hp < this.maxHp * 0.5) {
      this.transformed = true;
      flash('#FF88CC', 0.6); shakeScreen(12); playSound('bossIntro');
      this.attackCooldown = 2;
    }
    var speedMult = this.transformed ? 1.4 : 1;
    this.attackCooldown -= dt * speedMult;
    if (this.attackCooldown <= 0 && !this.currentAttack) {
      this.currentAttack = this.attacks[this.attackPattern % this.attacks.length];
      this.attackPattern++; this.attackDuration = 0;
      this.telegraph();
    }
    if (this.currentAttack) {
      this.attackDuration += dt;
      switch(this.currentAttack) {
        case 'deathBeam':
          if (this.attackDuration > 0.4 && this.attackDuration < 0.5 && player) {
            var dx = player.x - this.x; var dy = player.y + 15 - (this.y + 40);
            var dist = Math.sqrt(dx*dx+dy*dy) || 1;
            enemyProjectiles.push(new EnemyProjectile(this.x, this.y+40, (dx/dist)*180, (dy/dist)*180, '#FFAA88', 3, 10));
            if (this.transformed) {
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y+50, (dx/dist)*170, (dy/dist)*170, '#FFAA88', 3, 10));
            }
            playSound('kiBlast');
          }
          if (this.attackDuration > 1.5) {
            this.currentAttack = null; this.attackCooldown = 1.5 / speedMult;
            this.vulnerableTimer = 1.2;
          }
          break;
        case 'tailWhip':
          if (this.attackDuration > 0.5 && this.attackDuration < 0.7) {
            for (var i = 0; i < 7; i++) {
              var angle = -Math.PI * 0.8 + (i / 6) * Math.PI * 0.6;
              enemyProjectiles.push(new EnemyProjectile(
                this.x + 20, this.y + 120,
                Math.cos(angle) * 90, Math.sin(angle) * 90,
                '#88EEFF', 5, 8
              ));
            }
            playSound('melee');
          }
          if (this.attackDuration > 2) {
            this.currentAttack = null; this.attackCooldown = 1.8 / speedMult;
            this.vulnerableTimer = 1.2;
          }
          break;
        case 'supernova':
          if (this.attackDuration < 1.5) {
            // charging
            spawnChargeSparkle(this.x - 20, this.y + 30, 50, '#FF6600');
          } else if (this.attackDuration >= 1.5 && this.attackDuration < 1.7) {
            // fire
            enemyProjectiles.push(new EnemyProjectile(this.x-20, this.y+30, -80, 0, '#FFDD44', 20, 18));
            playSound('explosion'); shakeScreen(5);
          }
          if (this.attackDuration > 3) {
            this.currentAttack = null; this.attackCooldown = 2 / speedMult;
            this.vulnerableTimer = 1.5;
          }
          break;
      }
    }
    this.y = CANVAS_H/2 - 80 + Math.sin(this.age * 0.6) * 20;
  }
  draw(ctx) {
    if (!this.alive) return;
    var x = this.x, y = this.y;
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    var mainColor = this.transformed ? '#AAFFAA' : (fc || COLORS.bossLevel2Purple);
    var bellyColor = this.transformed ? '#CCFFCC' : (fc || '#AAFFAA');
    // serpentine body - long curved shape
    ctx.fillStyle = fc || mainColor;
    ctx.beginPath();
    ctx.moveTo(x + 20, y + 50);
    ctx.quadraticCurveTo(x + 64, y + 35, x + 100, y + 55);
    ctx.quadraticCurveTo(x + 120, y + 70, x + 110, y + 100);
    ctx.quadraticCurveTo(x + 100, y + 130, x + 80, y + 140);
    ctx.lineTo(x + 40, y + 140);
    ctx.quadraticCurveTo(x + 10, y + 120, x + 10, y + 90);
    ctx.quadraticCurveTo(x + 10, y + 65, x + 20, y + 50);
    ctx.closePath(); ctx.fill();
    // belly (lighter)
    ctx.fillStyle = fc || bellyColor;
    ctx.beginPath();
    ctx.ellipse(x + 60, y + 95, 25, 35, 0, 0, Math.PI * 2);
    ctx.fill();
    // gumdrop scale dots on body
    var scaleColors = ['#66CC22', '#77DD33', '#55BB11'];
    for (var i = 0; i < 8; i++) {
      ctx.fillStyle = fc || scaleColors[i % 3];
      var sx = x + 25 + Math.sin(i * 1.5) * 20 + (i % 3) * 10;
      var sy = y + 55 + i * 10;
      ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI * 2); ctx.fill();
    }
    // head - round candy dragon head
    ctx.fillStyle = fc || mainColor;
    ctx.beginPath(); ctx.arc(x + 64, y + 28, 26, 0, Math.PI * 2); ctx.fill();
    // candy cane horns (red/white striped)
    for (var h = 0; h < 2; h++) {
      var hx = h === 0 ? x + 42 : x + 86;
      var dir = h === 0 ? -1 : 1;
      for (var s = 0; s < 6; s++) {
        ctx.fillStyle = fc || (s % 2 === 0 ? '#FF4444' : '#FFFFFF');
        var hornY = y + 10 - s * 5;
        var hornX = hx + dir * s * 2;
        ctx.fillRect(hornX - 3, hornY, 6, 6);
      }
    }
    // big friendly-ish eyes
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(x + 54, y + 24, 9, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 74, y + 24, 9, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = this.transformed ? '#FF4488' : '#44AA44';
    ctx.beginPath(); ctx.arc(x + 55, y + 25, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 73, y + 25, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000000';
    ctx.beginPath(); ctx.arc(x + 55, y + 25, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 73, y + 25, 2, 0, Math.PI * 2); ctx.fill();
    // wafer cookie wings
    ctx.fillStyle = fc || '#FFCC88';
    // left wing
    ctx.beginPath();
    ctx.moveTo(x + 15, y + 55);
    ctx.lineTo(x - 20, y + 30 + Math.sin(this.age * 4) * 8);
    ctx.lineTo(x - 15, y + 70);
    ctx.closePath(); ctx.fill();
    // right wing
    ctx.beginPath();
    ctx.moveTo(x + 105, y + 55);
    ctx.lineTo(x + 140, y + 30 + Math.sin(this.age * 4) * 8);
    ctx.lineTo(x + 135, y + 70);
    ctx.closePath(); ctx.fill();
    // wafer grid lines on wings
    ctx.strokeStyle = fc || '#DDAA66';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x - 10, y + 40); ctx.lineTo(x + 5, y + 65); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + 130, y + 40); ctx.lineTo(x + 115, y + 65); ctx.stroke();
    // licorice whip tail
    ctx.strokeStyle = fc || COLORS.bossLevel2Tail;
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(x + 80, y + 138);
    ctx.quadraticCurveTo(x + 120, y + 140 + Math.sin(this.age * 3) * 15, x + 130, y + 120);
    ctx.quadraticCurveTo(x + 135, y + 105, x + 125, y + 95);
    ctx.stroke();
    ctx.lineWidth = 1;
    // small mouth
    ctx.fillStyle = fc || '#FF6688';
    ctx.beginPath(); ctx.arc(x + 64, y + 38, 5, 0, Math.PI); ctx.fill();
    // supernova charge effect
    if (this.currentAttack === 'supernova' && this.attackDuration < 1.5) {
      var progress = this.attackDuration / 1.5;
      ctx.save();
      ctx.globalAlpha = 0.4 + progress * 0.4;
      ctx.fillStyle = '#FF6600';
      ctx.beginPath(); ctx.arc(x - 20, y + 30, 10 + progress * 25, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#FFAA00';
      ctx.beginPath(); ctx.arc(x - 20, y + 30, 5 + progress * 15, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }
    // transformed rainbow sparkle aura (replaces purple aura)
    if (this.transformed) {
      ctx.save();
      var rainbowColors = ['#FF4444', '#FFAA44', '#FFFF44', '#44FF44', '#4488FF', '#AA44FF'];
      for (var i = 0; i < 12; i++) {
        var angle = this.age * 2 + i * (Math.PI * 2 / 12);
        var sparkR = 70 + Math.sin(this.age * 4 + i) * 15;
        var sparkX = x + 64 + Math.cos(angle) * sparkR;
        var sparkY = y + 70 + Math.sin(angle) * sparkR;
        ctx.globalAlpha = 0.4 + Math.sin(this.age * 6 + i) * 0.3;
        ctx.fillStyle = rainbowColors[i % rainbowColors.length];
        ctx.beginPath(); ctx.arc(sparkX, sparkY, 4 + Math.sin(this.age * 5 + i) * 2, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();
    }
    if (this.telegraphTimer > 0) {
      ctx.save(); ctx.globalAlpha = this.telegraphTimer;
      ctx.fillStyle = '#FFFFFF'; ctx.fillRect(x, y, this.w, this.h);
      ctx.restore();
    }
    this.drawBossBar(ctx);
  }
}

// ---- LEVEL 3 BOSS: Cosmic Demon King ----
class CosmicDemonKing extends Boss {
  constructor() {
    super(CANVAS_W + 50, CANVAS_H/2 - 110, 192, 220, 800, 'CAKE TITAN');
    this.attackPattern = 0;
    this.attacks = ['armSlam', 'mouthBeam', 'summon', 'darkRain'];
    this.attackCooldown = 3;
    this.extraArms = false;
    this.berserk = false;
    this.minionTimer = 0;
    this.enterTarget = CANVAS_W - 210;
  }
  update(dt) {
    super.update(dt);
    if (this.defeated || this.enteringScene) return;
    // phase transitions
    if (!this.extraArms && this.hp < this.maxHp * 0.6) {
      this.extraArms = true; this.phase = 2;
      flash('#FFD700', 0.5); shakeScreen(10); playSound('bossIntro');
    }
    if (!this.berserk && this.hp < this.maxHp * 0.3) {
      this.berserk = true; this.phase = 3;
      flash('#FFD700', 0.8); shakeScreen(15); playSound('bossIntro');
    }
    var speedMult = this.berserk ? 2 : (this.extraArms ? 1.5 : 1);
    this.attackCooldown -= dt * speedMult;
    // berserk constant shake
    if (this.berserk && Math.random() < 0.1) shakeScreen(2);
    if (this.attackCooldown <= 0 && !this.currentAttack) {
      if (this.berserk) {
        this.currentAttack = this.attacks[this.attackPattern % this.attacks.length];
      } else if (this.extraArms) {
        this.currentAttack = this.attacks[this.attackPattern % 3];
      } else {
        this.currentAttack = this.attacks[this.attackPattern % 3];
      }
      this.attackPattern++; this.attackDuration = 0;
      this.telegraph();
    }
    if (this.currentAttack) {
      this.attackDuration += dt;
      switch(this.currentAttack) {
        case 'armSlam':
          if (this.attackDuration > 0.5 && this.attackDuration < 0.7) {
            var slamCount = this.extraArms ? 6 : 4;
            for (var i = 0; i < slamCount; i++) {
              var sx = rand(50, CANVAS_W - 100);
              enemyProjectiles.push(new EnemyProjectile(sx, -20, 0, 130, '#FFAADD', 8, 12));
            }
            shakeScreen(8); playSound('melee');
          }
          if (this.attackDuration > 2.5) {
            this.currentAttack = null; this.attackCooldown = 2 / speedMult;
            this.vulnerableTimer = 1.5;
          }
          break;
        case 'mouthBeam':
          if (this.attackDuration > 0.8 && this.attackDuration < 2.3) {
            var beamY = this.y + 80 + Math.sin(this.attackDuration * 3) * 40;
            var beamBox = {x: 0, y: beamY - 10, w: this.x + 20, h: 20};
            if (player && !player.invincible && aabb(beamBox, player)) {
              player.takeDamage(3);
            }
          }
          if (this.attackDuration > 2.8) {
            this.currentAttack = null; this.attackCooldown = 2 / speedMult;
            this.vulnerableTimer = 1.5;
          }
          break;
        case 'summon':
          if (this.attackDuration > 0.5 && this.attackDuration < 0.7) {
            for (var i = 0; i < 3; i++) {
              enemies.push(new CellJunior(this.x - 40, this.y + 30 + i * 50));
            }
            playSound('bossIntro');
          }
          if (this.attackDuration > 3.5) {
            this.currentAttack = null; this.attackCooldown = 3 / speedMult;
            this.vulnerableTimer = 2;
          }
          break;
        case 'darkRain':
          if (this.attackDuration % 0.3 < dt) {
            for (var i = 0; i < 3; i++) {
              enemyProjectiles.push(new EnemyProjectile(
                rand(30, CANVAS_W - 80), -10,
                rand(-20, 20), rand(80, 140),
                '#FFAA44', 5, 7
              ));
            }
          }
          if (this.attackDuration > 3) {
            this.currentAttack = null; this.attackCooldown = 2.5 / speedMult;
            this.vulnerableTimer = 1.5;
          }
          break;
      }
    }
    this.y = CANVAS_H/2 - 110 + Math.sin(this.age * 0.4) * 25;
  }
  draw(ctx) {
    if (!this.alive) return;
    var x = this.x, y = this.y;
    var fc = this.flashTimer > 0 ? '#FFF' : null;
    // golden sparkle glow aura (replaces dark aura)
    ctx.save();
    ctx.globalAlpha = this.berserk ? 0.35 : 0.2;
    ctx.fillStyle = COLORS.bossLevel3Glow;
    ctx.beginPath(); ctx.arc(x + 96, y + 110, 130 + Math.sin(this.age * 2) * 10, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    // golden sparkle particles around aura
    ctx.save();
    for (var i = 0; i < 8; i++) {
      var sparkAngle = this.age * 1.5 + i * (Math.PI * 2 / 8);
      var sparkDist = 110 + Math.sin(this.age * 3 + i) * 20;
      var sparkX = x + 96 + Math.cos(sparkAngle) * sparkDist;
      var sparkY = y + 110 + Math.sin(sparkAngle) * sparkDist;
      ctx.globalAlpha = 0.3 + Math.sin(this.age * 5 + i * 2) * 0.2;
      ctx.fillStyle = '#FFD700';
      ctx.beginPath(); ctx.arc(sparkX, sparkY, 3 + Math.sin(this.age * 4 + i) * 1.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
    // === 3-TIER WEDDING CAKE BODY ===
    // bottom tier (widest) - white with pink trim
    ctx.fillStyle = fc || '#FFFFFF';
    ctx.fillRect(x + 30, y + 140, 132, 55);
    // pink trim on bottom tier
    ctx.fillStyle = fc || '#FFD4E8';
    ctx.fillRect(x + 30, y + 140, 132, 6);
    ctx.fillRect(x + 30, y + 189, 132, 6);
    // pink trim scallops on bottom tier
    for (var i = 0; i < 7; i++) {
      ctx.fillStyle = fc || '#FFD4E8';
      ctx.beginPath(); ctx.arc(x + 40 + i * 19, y + 175, 6, 0, Math.PI); ctx.fill();
    }
    // middle tier - ivory with gold trim
    ctx.fillStyle = fc || '#FFFFF0';
    ctx.fillRect(x + 48, y + 85, 96, 58);
    // gold trim on middle tier
    ctx.fillStyle = fc || '#FFD700';
    ctx.fillRect(x + 48, y + 85, 96, 5);
    ctx.fillRect(x + 48, y + 138, 96, 5);
    // gold trim scallops on middle tier
    for (var i = 0; i < 5; i++) {
      ctx.fillStyle = fc || '#FFD700';
      ctx.beginPath(); ctx.arc(x + 58 + i * 19, y + 125, 5, 0, Math.PI); ctx.fill();
    }
    // top tier (smallest) - with decorative dome top
    ctx.fillStyle = fc || '#FFFFFF';
    ctx.fillRect(x + 66, y + 45, 60, 43);
    // pink decorative trim on top tier
    ctx.fillStyle = fc || '#FFD4E8';
    ctx.fillRect(x + 66, y + 45, 60, 4);
    ctx.fillRect(x + 66, y + 84, 60, 4);
    // decorative dome topper
    ctx.fillStyle = fc || '#FFFFF0';
    ctx.beginPath(); ctx.arc(x + 96, y + 45, 20, Math.PI, 0); ctx.fill();
    // birthday candles on top (crown)
    var candleColors = ['#FF6688', '#88CCFF', '#FFDD44', '#88FF88', '#FFAACC'];
    for (var i = 0; i < 5; i++) {
      var cx = x + 76 + i * 10;
      var cy = y + 20;
      // candle stick
      ctx.fillStyle = fc || candleColors[i];
      ctx.fillRect(cx - 2, cy, 4, 18);
      // flame
      ctx.fillStyle = fc || '#FFDD44';
      ctx.beginPath(); ctx.arc(cx, cy - 2, 4, 0, Math.PI * 2); ctx.fill();
      // flame inner
      ctx.fillStyle = fc || '#FFFFFF';
      ctx.beginPath(); ctx.arc(cx, cy - 1, 2, 0, Math.PI * 2); ctx.fill();
      // flame flicker
      ctx.fillStyle = '#FFAA22';
      ctx.globalAlpha = 0.5 + Math.sin(this.age * 8 + i * 1.3) * 0.3;
      ctx.beginPath(); ctx.arc(cx, cy - 4, 3 + Math.sin(this.age * 10 + i) * 1.5, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
    }
    // candy eyes on the middle tier
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(x + 82, y + 105, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 110, y + 105, 8, 0, Math.PI * 2); ctx.fill();
    // eye color
    ctx.fillStyle = this.berserk ? '#FF4488' : COLORS.bossLevel3Eyes;
    var eyeSize = this.berserk ? 5 : 4;
    ctx.beginPath(); ctx.arc(x + 80, y + 106, eyeSize, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 108, y + 106, eyeSize, 0, Math.PI * 2); ctx.fill();
    // pupils
    ctx.fillStyle = '#000000';
    ctx.beginPath(); ctx.arc(x + 80, y + 106, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 108, y + 106, 2, 0, Math.PI * 2); ctx.fill();
    // mouth on middle tier
    ctx.fillStyle = fc || '#FF88AA';
    ctx.beginPath(); ctx.arc(x + 96, y + 120, 8, 0, Math.PI); ctx.fill();
    // fondant decorative arms
    ctx.fillStyle = fc || '#FFE4CC';
    ctx.fillRect(x + 16, y + 95, 34, 16);
    ctx.fillRect(x + 142, y + 95, 34, 16);
    // fondant arm hands (rounded ends)
    ctx.fillStyle = fc || '#FFD4BB';
    ctx.beginPath(); ctx.arc(x + 16, y + 103, 10, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + 176, y + 103, 10, 0, Math.PI * 2); ctx.fill();
    // extra fondant arms (phase 2+)
    if (this.extraArms) {
      ctx.fillStyle = fc || '#FFE4CC';
      ctx.fillRect(x + 20, y + 150, 32, 14);
      ctx.fillRect(x + 140, y + 150, 32, 14);
      ctx.fillStyle = fc || '#FFD4BB';
      ctx.beginPath(); ctx.arc(x + 20, y + 157, 9, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 172, y + 157, 9, 0, Math.PI * 2); ctx.fill();
    }
    // frosting stream effect (replaces mouth beam, purple to pink)
    if (this.currentAttack === 'mouthBeam' && this.attackDuration > 0.8 && this.attackDuration < 2.3) {
      var beamY = y + 80 + Math.sin(this.attackDuration * 3) * 40;
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#FF88CC';
      ctx.fillRect(0, beamY - 14, x + 50, 28);
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#FFAADD';
      ctx.fillRect(0, beamY - 8, x + 50, 16);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, beamY - 2, x + 50, 4);
      ctx.restore();
    }
    // berserk warm golden glow overlay (replaces dark overlay)
    if (this.berserk) {
      ctx.save();
      ctx.globalAlpha = 0.08 + Math.sin(this.age * 8) * 0.04;
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
      ctx.restore();
    }
    if (this.telegraphTimer > 0) {
      ctx.save(); ctx.globalAlpha = this.telegraphTimer;
      ctx.fillStyle = '#FFFFFF'; ctx.fillRect(x, y, this.w, this.h);
      ctx.restore();
    }
    this.drawBossBar(ctx);
  }
}

// === END ENEMIES AND BOSSES ===
// === LEVELS, UI, AND GAME LOOP ===

// ---- PARALLAX BACKGROUNDS ----

function drawLevelBackground(ctx, level, scrollX, age) {
  switch(level) {
    case 0: drawEarthBg(ctx, scrollX, age); break;
    case 1: drawNamekBg(ctx, scrollX, age); break;
    case 2: drawDarkRealmBg(ctx, scrollX, age); break;
  }
}

function drawEarthBg(ctx, scrollX, age) {
  // sky: soft pink gradient
  var skyGrd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  skyGrd.addColorStop(0, '#FFD4E8');
  skyGrd.addColorStop(1, '#FFBBDD');
  ctx.fillStyle = skyGrd;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  // cotton candy clouds (pink and blue fluffy shapes)
  var farOff = -(scrollX * 0.1) % CANVAS_W;
  for (var i = 0; i < 6; i++) {
    var cx = ((i * 200 + farOff) % (CANVAS_W + 200)) - 100;
    var cy = 40 + (i % 3) * 35;
    ctx.fillStyle = (i % 2 === 0) ? '#FFCCEE' : '#CCDDFF';
    drawCloud(ctx, cx, cy, 30 + (i % 2) * 15);
  }
  // candy cane mountains: striped red/white peaks
  var mOff = -(scrollX * 0.2) % 400;
  for (var i = -1; i < 5; i++) {
    var mx = i * 300 + mOff;
    var peakY = 180 + (i % 2) * 30;
    // white base triangle
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.moveTo(mx, 350); ctx.lineTo(mx + 150, peakY); ctx.lineTo(mx + 300, 350); ctx.fill();
    // red stripes across the mountain
    ctx.fillStyle = '#FF6688';
    for (var s = 0; s < 4; s++) {
      var t0 = (s * 2) / 8;
      var t1 = (s * 2 + 1) / 8;
      var y0 = 350 - (350 - peakY) * t0;
      var y1 = 350 - (350 - peakY) * t1;
      var hw0 = 150 * (1 - t0);
      var hw1 = 150 * (1 - t1);
      ctx.beginPath();
      ctx.moveTo(mx + 150 - hw0, y0);
      ctx.lineTo(mx + 150 - hw1, y1);
      ctx.lineTo(mx + 150 + hw1, y1);
      ctx.lineTo(mx + 150 + hw0, y0);
      ctx.fill();
    }
  }
  // gumdrop hills (mid layer): colorful rounded bumps
  var gumColors = ['#FF88AA', '#88DDFF', '#88FF88', '#FFEE66'];
  var hOff = -(scrollX * 0.4) % 600;
  for (var i = -1; i < 7; i++) {
    var hx = i * 170 + hOff;
    ctx.fillStyle = gumColors[((i % 4) + 4) % 4];
    ctx.beginPath();
    ctx.arc(hx + 85, 420, 65, Math.PI, 0);
    ctx.closePath();
    ctx.fill();
  }
  // ground: cookie crumble
  ctx.fillStyle = '#DDAA77';
  ctx.fillRect(0, 420, CANVAS_W, 120);
  ctx.fillStyle = '#EECC99';
  ctx.fillRect(0, 415, CANVAS_W, 8);
  // scattered candy: small colored gumdrops on the ground
  var candyColors = ['#FF4466', '#44AAFF', '#44DD44', '#FFAA00', '#FF66CC', '#AADD00'];
  var rOff = -(scrollX * 0.6) % 800;
  for (var i = 0; i < 10; i++) {
    var rx = ((i * 110 + rOff) % (CANVAS_W + 200));
    var ry = 435 + (i % 3) * 15;
    ctx.fillStyle = candyColors[i % candyColors.length];
    ctx.beginPath();
    ctx.arc(rx, ry, 4 + (i % 3) * 2, 0, Math.PI * 2);
    ctx.fill();
    // highlight on candy
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(rx - 1, ry - 1, 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating candy particles in the air (parallax layer)
  var floatOff = -(scrollX * 0.25) % 1200;
  var floatColors = ['#FF88CC', '#88DDFF', '#FFEE66', '#88FF88'];
  for (var i = 0; i < 8; i++) {
    var fx = ((i * 170 + floatOff + i * i * 37) % (CANVAS_W + 200)) - 50;
    var fy = 80 + (i * 47 % 280) + Math.sin(age * 1.5 + i * 1.3) * 15;
    var fsize = 3 + (i % 3) * 2;
    ctx.globalAlpha = 0.25 + Math.sin(age * 2 + i * 0.8) * 0.15;
    ctx.fillStyle = floatColors[i % floatColors.length];
    ctx.save();
    ctx.translate(fx, fy);
    ctx.rotate(age * 0.5 + i);
    // Star shape
    if (i % 2 === 0) {
      ctx.beginPath();
      for (var s = 0; s < 5; s++) {
        var sa = s * Math.PI * 2 / 5 - Math.PI / 2;
        if (s === 0) ctx.moveTo(Math.cos(sa) * fsize, Math.sin(sa) * fsize);
        else ctx.lineTo(Math.cos(sa) * fsize, Math.sin(sa) * fsize);
        var sa2 = sa + Math.PI / 5;
        ctx.lineTo(Math.cos(sa2) * fsize * 0.4, Math.sin(sa2) * fsize * 0.4);
      }
      ctx.closePath(); ctx.fill();
    } else {
      ctx.beginPath(); ctx.arc(0, 0, fsize, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }
  ctx.globalAlpha = 1;
}

function drawCloud(ctx, x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.arc(x + r * 0.8, y - r * 0.3, r * 0.7, 0, Math.PI * 2);
  ctx.arc(x - r * 0.6, y - r * 0.1, r * 0.6, 0, Math.PI * 2);
  ctx.arc(x + r * 0.3, y + r * 0.1, r * 0.5, 0, Math.PI * 2);
  ctx.fill();
}

function drawNamekBg(ctx, scrollX, age) {
  // sky: warm golden/amber gradient
  var skyGrd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  skyGrd.addColorStop(0, '#FFCC88');
  skyGrd.addColorStop(1, '#FFE0AA');
  ctx.fillStyle = skyGrd;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  // chocolate sun: brown circle with golden glow
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#FFAA44';
  ctx.beginPath(); ctx.arc(200, 70, 55, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
  ctx.fillStyle = '#884422';
  ctx.beginPath(); ctx.arc(200, 70, 35, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#AA6633';
  ctx.beginPath(); ctx.arc(195, 62, 10, 0, Math.PI * 2); ctx.fill();
  // wafer towers (far): tall tan rectangles with grid lines
  var sOff = -(scrollX * 0.15) % 600;
  for (var i = -1; i < 6; i++) {
    var sx = i * 180 + sOff;
    var sh = 100 + (i % 3) * 50;
    ctx.fillStyle = '#FFCC88';
    ctx.fillRect(sx + 5, 300 - sh, 30, sh + 50);
    // grid lines on wafer
    ctx.strokeStyle = '#DDAA66';
    ctx.lineWidth = 1;
    for (var g = 0; g < sh + 50; g += 10) {
      ctx.beginPath(); ctx.moveTo(sx + 5, 300 - sh + g); ctx.lineTo(sx + 35, 300 - sh + g); ctx.stroke();
    }
    for (var g = 0; g < 30; g += 10) {
      ctx.beginPath(); ctx.moveTo(sx + 5 + g, 300 - sh); ctx.lineTo(sx + 5 + g, 350); ctx.stroke();
    }
  }
  // cookie buildings (mid): round/dome shapes with square windows
  var bOff = -(scrollX * 0.35) % 700;
  for (var i = 0; i < 4; i++) {
    var bx = ((i * 220 + bOff) % (CANVAS_W + 200));
    ctx.fillStyle = '#DDAA66';
    ctx.beginPath(); ctx.arc(bx + 25, 380, 30, Math.PI, 0); ctx.closePath(); ctx.fill();
    ctx.fillRect(bx - 5, 380, 60, 30);
    // square windows
    ctx.fillStyle = '#FFEE99';
    ctx.fillRect(bx + 5, 385, 10, 10);
    ctx.fillRect(bx + 30, 385, 10, 10);
  }
  // ground: rich chocolate brown
  ctx.fillStyle = '#553311';
  ctx.fillRect(0, 400, CANVAS_W, 140);
  ctx.fillStyle = '#664422';
  ctx.fillRect(0, 395, CANVAS_W, 8);
  // chocolate river: wavy brown stripe with highlights
  var rOff = -(scrollX * 0.5) % 500;
  ctx.fillStyle = '#442211';
  ctx.beginPath();
  ctx.moveTo(0, 440);
  for (var x = 0; x <= CANVAS_W; x += 20) {
    ctx.lineTo(x, 440 + Math.sin((x + rOff) * 0.03) * 6);
  }
  for (var x = CANVAS_W; x >= 0; x -= 20) {
    ctx.lineTo(x, 455 + Math.sin((x + rOff) * 0.03) * 4);
  }
  ctx.closePath();
  ctx.fill();
  // river highlights
  ctx.strokeStyle = '#663322';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (var x = 0; x <= CANVAS_W; x += 20) {
    if (x === 0) ctx.moveTo(x, 447 + Math.sin((x + rOff) * 0.03) * 5);
    else ctx.lineTo(x, 447 + Math.sin((x + rOff) * 0.03) * 5);
  }
  ctx.stroke();
  ctx.lineWidth = 1;
  // scattered cocoa beans: small brown ovals
  var cOff = -(scrollX * 0.6) % 800;
  ctx.fillStyle = '#553322';
  for (var i = 0; i < 8; i++) {
    var cx = ((i * 130 + cOff) % (CANVAS_W + 200));
    var cy = 465 + (i % 3) * 12;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 6, 4, (i * 0.5), 0, Math.PI * 2);
    ctx.fill();
    // highlight on bean
    ctx.fillStyle = '#774433';
    ctx.beginPath();
    ctx.ellipse(cx - 1, cy - 1, 3, 2, (i * 0.5), 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#553322';
  }
}

function drawDarkRealmBg(ctx, scrollX, age) {
  // sky: light ethereal blue-white (magical candy realm)
  var skyGrd = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  skyGrd.addColorStop(0, '#DDEEFF');
  skyGrd.addColorStop(1, '#EEEEFF');
  ctx.fillStyle = skyGrd;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  // rainbow streaks: diagonal stripes with low opacity
  ctx.save();
  ctx.globalAlpha = 0.15;
  var rainbowColors = ['#FFAAAA', '#FFDDAA', '#FFFFAA', '#AAFFAA', '#AADDFF', '#DDAAFF'];
  for (var i = 0; i < rainbowColors.length; i++) {
    ctx.fillStyle = rainbowColors[i];
    ctx.beginPath();
    var rx = 80 + i * 120 + Math.sin(age * 0.3 + i) * 20;
    ctx.moveTo(rx, 0);
    ctx.lineTo(rx + 60, 0);
    ctx.lineTo(rx - 100, CANVAS_H);
    ctx.lineTo(rx - 160, CANVAS_H);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
  // star sprinkles: small colored dots twinkling
  var starOff = -(scrollX * 0.1) % CANVAS_W;
  var sprinkleColors = ['#FFAACC', '#AACCFF', '#CCFFAA', '#FFDDAA', '#DDAAFF', '#AAFFDD'];
  for (var i = 0; i < 50; i++) {
    var sx = ((i * 47 + starOff + i * i * 7) % CANVAS_W);
    var sy = (i * 31 + i * i * 3) % (CANVAS_H - 100);
    var ss = (i % 3 === 0) ? 3 : 2;
    ctx.globalAlpha = 0.5 + Math.sin(age * 2 + i) * 0.3;
    ctx.fillStyle = sprinkleColors[i % sprinkleColors.length];
    ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
  // sugar crystals (mid layer): geometric shapes with white highlights
  var dOff = -(scrollX * 0.3) % 800;
  var crystalColors = ['#CCDDFF', '#FFCCDD', '#DDFFCC'];
  for (var i = 0; i < 6; i++) {
    var dx = ((i * 180 + dOff) % (CANVAS_W + 200)) - 50;
    var dy = 200 + (i % 3) * 80 + Math.sin(age + i * 2) * 15;
    var cSize = 15 + (i % 3) * 8;
    ctx.fillStyle = crystalColors[i % crystalColors.length];
    ctx.save();
    ctx.translate(dx, dy);
    ctx.rotate(age * 0.1 + i);
    // draw diamond shape
    ctx.beginPath();
    ctx.moveTo(0, -cSize);
    ctx.lineTo(cSize * 0.6, 0);
    ctx.lineTo(0, cSize);
    ctx.lineTo(-cSize * 0.6, 0);
    ctx.closePath();
    ctx.fill();
    // white sparkle highlight
    ctx.fillStyle = '#FFFFFF';
    ctx.globalAlpha = 0.6 + Math.sin(age * 3 + i * 1.5) * 0.3;
    ctx.beginPath(); ctx.arc(-cSize * 0.15, -cSize * 0.3, cSize * 0.15, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  // floating candy platforms: colorful rectangles/ovals
  var pOff = -(scrollX * 0.4) % 600;
  var platColors = ['#FF99BB', '#99CCFF', '#BBFF99', '#FFCC99', '#CC99FF'];
  for (var i = 0; i < 4; i++) {
    var px = ((i * 200 + pOff) % (CANVAS_W + 200));
    var py = 300 + (i % 2) * 40 + Math.sin(age * 0.8 + i * 1.5) * 10;
    ctx.fillStyle = platColors[i % platColors.length];
    ctx.beginPath();
    ctx.ellipse(px + 30, py, 35, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    // candy stripe on platform
    ctx.fillStyle = '#FFFFFF';
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.ellipse(px + 30, py - 2, 25, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  // ground: sparkling sugar surface
  ctx.fillStyle = '#EEEEFF';
  ctx.fillRect(0, 430, CANVAS_W, 110);
  ctx.fillStyle = '#DDDDFF';
  ctx.fillRect(0, 425, CANVAS_W, 8);
  // sparkle dots on the ground
  var crOff = -(scrollX * 0.6) % 400;
  for (var i = 0; i < 20; i++) {
    var crx = ((i * 55 + crOff) % (CANVAS_W + 100));
    var cry = 440 + (i % 4) * 15;
    ctx.globalAlpha = 0.4 + Math.sin(age * 3 + i * 2) * 0.3;
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(crx, cry, 2, 0, Math.PI * 2); ctx.fill();
    // colored sparkle next to white
    ctx.fillStyle = sprinkleColors[i % sprinkleColors.length];
    ctx.beginPath(); ctx.arc(crx + 8, cry + 3, 1.5, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ---- LEVEL SPAWN DATA ----

var levelConfigs = [
  { // Level 0 (Earth)
    duration: 90,
    bossClass: GiantMechRobot,
    name: 'CANDY FIELDS',
    subtitle: 'SWEET MEADOWS',
    spawns: [
      {t:2, type:'RedRibbonSoldier', count:2, yMin:200, yMax:380},
      {t:6, type:'RedRibbonSoldier', count:3, yMin:150, yMax:400},
      {t:12, type:'BattleRobot', count:1, yMin:80, yMax:200},
      {t:16, type:'RedRibbonSoldier', count:2, yMin:250, yMax:380},
      {t:20, type:'BattleRobot', count:2, yMin:60, yMax:250},
      {t:26, type:'NinjaAssassin', count:2, yMin:150, yMax:350},
      {t:30, type:'RedRibbonSoldier', count:3, yMin:180, yMax:400},
      {t:34, type:'BattleRobot', count:2, yMin:80, yMax:200},
      {t:40, type:'NinjaAssassin', count:3, yMin:100, yMax:380},
      {t:45, type:'RedRibbonSoldier', count:2, yMin:200, yMax:350},
      {t:45, type:'BattleRobot', count:1, yMin:80, yMax:150},
      {t:52, type:'NinjaAssassin', count:2, yMin:150, yMax:300},
      {t:52, type:'RedRibbonSoldier', count:2, yMin:300, yMax:400},
      {t:58, type:'BattleRobot', count:3, yMin:60, yMax:300},
      {t:64, type:'NinjaAssassin', count:3, yMin:100, yMax:380},
      {t:64, type:'RedRibbonSoldier', count:3, yMin:200, yMax:400},
      {t:72, type:'BattleRobot', count:2, yMin:100, yMax:250},
      {t:72, type:'NinjaAssassin', count:2, yMin:250, yMax:380},
      {t:78, type:'RedRibbonSoldier', count:4, yMin:150, yMax:400},
      {t:78, type:'BattleRobot', count:2, yMin:60, yMax:200},
      {t:84, type:'NinjaAssassin', count:4, yMin:100, yMax:400},
    ]
  },
  { // Level 1 (Namek)
    duration: 120,
    bossClass: AlienTyrant,
    name: 'CHOCOLATE KINGDOM',
    subtitle: 'COCOA CASTLE',
    spawns: [
      {t:2, type:'FriezaSoldier', count:2, yMin:100, yMax:350},
      {t:8, type:'FriezaSoldier', count:3, yMin:80, yMax:380},
      {t:14, type:'FriezaSoldier', count:2, yMin:150, yMax:300},
      {t:20, type:'BruteWarrior', count:1, yMin:200, yMax:350},
      {t:26, type:'FriezaSoldier', count:3, yMin:100, yMax:380},
      {t:30, type:'BruteWarrior', count:1, yMin:150, yMax:300},
      {t:30, type:'FriezaSoldier', count:2, yMin:80, yMax:200},
      {t:38, type:'FriezaSoldier', count:3, yMin:100, yMax:380},
      {t:44, type:'BruteWarrior', count:2, yMin:150, yMax:380},
      {t:50, type:'GinyuStriker', count:3, yMin:100, yMax:350},
      {t:56, type:'FriezaSoldier', count:2, yMin:80, yMax:250},
      {t:56, type:'GinyuStriker', count:3, yMin:250, yMax:400},
      {t:64, type:'BruteWarrior', count:2, yMin:150, yMax:350},
      {t:64, type:'FriezaSoldier', count:2, yMin:80, yMax:200},
      {t:72, type:'GinyuStriker', count:3, yMin:100, yMax:380},
      {t:72, type:'BruteWarrior', count:1, yMin:200, yMax:350},
      {t:80, type:'FriezaSoldier', count:4, yMin:80, yMax:400},
      {t:80, type:'GinyuStriker', count:3, yMin:150, yMax:350},
      {t:90, type:'BruteWarrior', count:2, yMin:150, yMax:350},
      {t:90, type:'FriezaSoldier', count:3, yMin:100, yMax:300},
      {t:100, type:'GinyuStriker', count:3, yMin:100, yMax:380},
      {t:100, type:'BruteWarrior', count:2, yMin:200, yMax:380},
      {t:110, type:'FriezaSoldier', count:4, yMin:80, yMax:400},
      {t:110, type:'GinyuStriker', count:3, yMin:150, yMax:350},
    ]
  },
  { // Level 2 (Dark Realm)
    duration: 150,
    bossClass: CosmicDemonKing,
    name: 'SUGAR CRYSTAL REALM',
    subtitle: 'CRYSTAL PALACE',
    spawns: [
      {t:2, type:'CellJunior', count:2, yMin:100, yMax:350},
      {t:8, type:'CellJunior', count:3, yMin:80, yMax:400},
      {t:16, type:'CellJunior', count:2, yMin:100, yMax:300},
      {t:22, type:'CellJunior', count:3, yMin:80, yMax:380},
      {t:30, type:'DarkClone', count:1, yMin:150, yMax:350},
      {t:36, type:'CellJunior', count:3, yMin:100, yMax:380},
      {t:36, type:'DarkClone', count:1, yMin:200, yMax:350},
      {t:44, type:'CellJunior', count:2, yMin:80, yMax:250},
      {t:44, type:'DarkClone', count:2, yMin:200, yMax:400},
      {t:54, type:'CellJunior', count:3, yMin:100, yMax:380},
      {t:60, type:'BuuBlob', count:2, yMin:150, yMax:350},
      {t:68, type:'DarkClone', count:2, yMin:100, yMax:350},
      {t:68, type:'BuuBlob', count:1, yMin:200, yMax:350},
      {t:76, type:'CellJunior', count:3, yMin:80, yMax:400},
      {t:76, type:'BuuBlob', count:2, yMin:150, yMax:380},
      {t:86, type:'DarkClone', count:2, yMin:100, yMax:350},
      {t:86, type:'CellJunior', count:2, yMin:200, yMax:400},
      {t:96, type:'BuuBlob', count:3, yMin:100, yMax:380},
      {t:96, type:'DarkClone', count:1, yMin:200, yMax:300},
      {t:106, type:'CellJunior', count:4, yMin:80, yMax:400},
      {t:106, type:'BuuBlob', count:2, yMin:150, yMax:350},
      {t:116, type:'DarkClone', count:2, yMin:100, yMax:350},
      {t:116, type:'CellJunior', count:3, yMin:150, yMax:400},
      {t:126, type:'BuuBlob', count:3, yMin:100, yMax:400},
      {t:126, type:'DarkClone', count:2, yMin:150, yMax:350},
      {t:136, type:'CellJunior', count:4, yMin:80, yMax:400},
      {t:136, type:'BuuBlob', count:2, yMin:200, yMax:380},
      {t:136, type:'DarkClone', count:2, yMin:100, yMax:300},
    ]
  }
];

var enemyClasses = {
  'RedRibbonSoldier': RedRibbonSoldier,
  'BattleRobot': BattleRobot,
  'NinjaAssassin': NinjaAssassin,
  'FriezaSoldier': FriezaSoldier,
  'BruteWarrior': BruteWarrior,
  'GinyuStriker': GinyuStriker,
  'CellJunior': CellJunior,
  'DarkClone': DarkClone,
  'BuuBlob': BuuBlob
};

// ---- GAME STATE ----

var gameState = STATE.MENU;
var pausedFromState = STATE.PLAYING;
var currentLevel = 0;
var levelTimer = 0;
var levelScrollX = 0;
var spawnIndex = 0;
var bossActive = false;
var bossTriggered = false;
var introTimer = 0;
var introCountdown = 4;
var levelCompleteTimer = 0;
var gameAge = 0;
var highScore = parseInt(localStorage.getItem('gokuHighScore')) || 0;
var projectiles = [];
var menuScrollX = 0;

// ---- SCREEN TRANSITIONS ----

function startTransition(callback) {
  screenTransition.active = true;
  screenTransition.fadeIn = false;
  screenTransition.alpha = 0;
  screenTransition.elapsed = 0;
  screenTransition.callback = callback;
}

function updateTransition(dt) {
  if (!screenTransition.active) return;
  screenTransition.elapsed += dt;
  var half = screenTransition.duration / 2;
  if (!screenTransition.fadeIn) {
    screenTransition.alpha = Math.min(1, screenTransition.elapsed / half);
    if (screenTransition.elapsed >= half) {
      screenTransition.fadeIn = true;
      screenTransition.elapsed = 0;
      if (screenTransition.callback) screenTransition.callback();
    }
  } else {
    screenTransition.alpha = Math.max(0, 1 - screenTransition.elapsed / half);
    if (screenTransition.elapsed >= half) {
      screenTransition.active = false;
      screenTransition.alpha = 0;
    }
  }
}

function drawTransition(ctx) {
  if (!screenTransition.active || screenTransition.alpha <= 0) return;
  ctx.save();
  ctx.globalAlpha = screenTransition.alpha;
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  ctx.restore();
}

// ---- PAUSE SCREEN ----

function drawPauseScreen(ctx) {
  // Dim overlay
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Pause box background
  var bw = 320, bh = 220;
  var bx = (CANVAS_W - bw) / 2, by = (CANVAS_H - bh) / 2;

  // Rounded rectangle background
  ctx.fillStyle = 'rgba(255, 220, 240, 0.95)';
  ctx.beginPath();
  var r = 16;
  ctx.moveTo(bx + r, by);
  ctx.lineTo(bx + bw - r, by);
  ctx.quadraticCurveTo(bx + bw, by, bx + bw, by + r);
  ctx.lineTo(bx + bw, by + bh - r);
  ctx.quadraticCurveTo(bx + bw, by + bh, bx + bw - r, by + bh);
  ctx.lineTo(bx + r, by + bh);
  ctx.quadraticCurveTo(bx, by + bh, bx, by + bh - r);
  ctx.lineTo(bx, by + r);
  ctx.quadraticCurveTo(bx, by, bx + r, by);
  ctx.closePath();
  ctx.fill();

  // Candy border
  ctx.strokeStyle = '#FF88CC';
  ctx.lineWidth = 4;
  ctx.stroke();

  // Title
  drawPixelTextCenteredWithShadow(ctx, 'PAUSED', CANVAS_W / 2, by + 30, 5, '#FF6699', '#993355');

  // Candy divider
  ctx.strokeStyle = '#FFAACC';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bx + 30, by + 70);
  ctx.lineTo(bx + bw - 30, by + 70);
  ctx.stroke();

  // Instructions
  drawPixelTextCentered(ctx, 'PRESS ESC TO RESUME', CANVAS_W / 2, by + 100, 2.5, '#884466');
  drawPixelTextCentered(ctx, 'PRESS ENTER FOR MENU', CANVAS_W / 2, by + 130, 2.5, '#884466');

  // Controls reminder
  drawPixelTextCentered(ctx, 'ARROWS:MOVE Z:SHOOT X:HIT', CANVAS_W / 2, by + 170, 2, '#AA7799');
  drawPixelTextCentered(ctx, 'C:BEAM V:SUPER', CANVAS_W / 2, by + 190, 2, '#AA7799');

  ctx.restore();
}

// ---- TUTORIAL OVERLAY ----

var tutorialSteps = [
  { text: 'USE ARROW KEYS TO MOVE', icon: 'arrows', duration: 3.5 },
  { text: 'PRESS Z TO SHOOT COOKIES', icon: 'z', duration: 3 },
  { text: 'PRESS X FOR MELEE ATTACK', icon: 'x', duration: 3 },
  { text: 'HOLD C FOR RAINBOW BEAM', icon: 'c', duration: 3 },
  { text: 'COLLECT CANDY FOR POWER', icon: 'candy', duration: 3 },
  { text: 'GOOD LUCK! HAVE FUN!', icon: 'star', duration: 2.5 }
];

function updateTutorial(dt) {
  if (!showTutorial) return;
  tutorialTimer += dt;
  if (tutorialTimer >= tutorialSteps[tutorialStep].duration) {
    tutorialTimer = 0;
    tutorialStep++;
    if (tutorialStep >= tutorialSteps.length) {
      showTutorial = false;
      localStorage.setItem('gokuTutorialSeen', '1');
    }
  }
}

function drawTutorial(ctx) {
  if (!showTutorial || tutorialStep >= tutorialSteps.length) return;
  var step = tutorialSteps[tutorialStep];
  var fadeIn = Math.min(1, tutorialTimer / 0.3);
  var fadeOut = tutorialTimer > step.duration - 0.5 ? Math.max(0, (step.duration - tutorialTimer) / 0.5) : 1;
  var alpha = fadeIn * fadeOut;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Background pill
  var tw = 360, th = 50;
  var tx = (CANVAS_W - tw) / 2, ty = CANVAS_H / 2 + 80;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.beginPath();
  ctx.arc(tx + th / 2, ty + th / 2, th / 2, Math.PI * 0.5, Math.PI * 1.5);
  ctx.arc(tx + tw - th / 2, ty + th / 2, th / 2, Math.PI * 1.5, Math.PI * 0.5);
  ctx.closePath();
  ctx.fill();

  // Icon
  var iconX = tx + 30, iconY = ty + 14;
  ctx.fillStyle = '#FFD700';
  if (step.icon === 'arrows') {
    // Arrow icon
    ctx.beginPath();
    ctx.moveTo(iconX, iconY + 10); ctx.lineTo(iconX + 10, iconY); ctx.lineTo(iconX + 20, iconY + 10);
    ctx.lineTo(iconX + 15, iconY + 10); ctx.lineTo(iconX + 15, iconY + 20);
    ctx.lineTo(iconX + 5, iconY + 20); ctx.lineTo(iconX + 5, iconY + 10);
    ctx.closePath(); ctx.fill();
  } else if (step.icon === 'star') {
    for (var i = 0; i < 5; i++) {
      var a = i * Math.PI * 2 / 5 - Math.PI / 2;
      var ox = iconX + 10 + Math.cos(a) * 10;
      var oy = iconY + 10 + Math.sin(a) * 10;
      if (i === 0) ctx.moveTo(ox, oy);
      else ctx.lineTo(ox, oy);
      var a2 = a + Math.PI / 5;
      ctx.lineTo(iconX + 10 + Math.cos(a2) * 5, iconY + 10 + Math.sin(a2) * 5);
    }
    ctx.closePath(); ctx.fill();
  } else if (step.icon === 'candy') {
    ctx.fillStyle = '#FF88CC';
    ctx.beginPath(); ctx.arc(iconX + 10, iconY + 10, 8, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath(); ctx.arc(iconX + 7, iconY + 7, 3, 0, Math.PI * 2); ctx.fill();
  } else {
    // Key icon
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(iconX, iconY, 22, 22);
    ctx.fillStyle = '#FF6699';
    ctx.fillRect(iconX + 2, iconY + 2, 18, 18);
    drawPixelText(ctx, step.icon.toUpperCase(), iconX + 5, iconY + 5, 2, '#FFFFFF');
  }

  // Text
  drawPixelText(ctx, step.text, tx + 60, ty + 16, 2.5, '#FFFFFF');

  ctx.restore();
}

// ---- HUD ----

function drawRoundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawHUD(ctx) {
  if (!player) return;

  // ---- HUD Background Panel (top-left) ----
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = 'rgba(60, 20, 40, 0.6)';
  drawRoundedRect(ctx, 6, 4, 230, 54, 10);
  ctx.fill();
  ctx.restore();

  // HP Bar with cookie jar icon
  var hpX = 12, hpY = 10, hpW = 170, hpH = 18;
  // Cookie jar icon
  ctx.fillStyle = '#CC8844';
  ctx.beginPath(); ctx.arc(hpX + 10, hpY + 9, 8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFDDBB';
  ctx.beginPath(); ctx.arc(hpX + 8, hpY + 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#AA6633';
  ctx.fillRect(hpX + 5, hpY + 1, 10, 3);

  var barX = hpX + 24;
  // Bar background with rounded shape
  ctx.fillStyle = 'rgba(255, 230, 210, 0.5)';
  drawRoundedRect(ctx, barX, hpY, hpW, hpH, 4);
  ctx.fill();

  var hpPct = Math.max(0, player.hp / player.maxHp);
  var hpColor = hpPct > 0.5 ? '#44DD66' : hpPct > 0.25 ? '#FFBB33' : '#FF4466';
  // Gradient HP fill
  var hpGrad = ctx.createLinearGradient(barX, hpY, barX, hpY + hpH);
  hpGrad.addColorStop(0, hpColor);
  hpGrad.addColorStop(1, hpPct > 0.5 ? '#22AA44' : hpPct > 0.25 ? '#DD8800' : '#CC2244');
  ctx.fillStyle = hpGrad;
  drawRoundedRect(ctx, barX, hpY, hpW * hpPct, hpH, 4);
  ctx.fill();
  // HP pulse when low
  if (hpPct <= 0.25 && hpPct > 0) {
    ctx.save();
    ctx.globalAlpha = 0.3 + Math.sin(gameAge * 8) * 0.2;
    ctx.fillStyle = '#FF0000';
    drawRoundedRect(ctx, barX, hpY, hpW * hpPct, hpH, 4);
    ctx.fill();
    ctx.restore();
  }
  // Border
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.lineWidth = 1.5;
  drawRoundedRect(ctx, barX, hpY, hpW, hpH, 4);
  ctx.stroke();
  // HP text
  drawPixelText(ctx, Math.ceil(player.hp) + '/' + player.maxHp, barX + 4, hpY + 4, 1.5, '#FFFFFF');

  // Candy/Ki Bar with candy icon
  var kiY = hpY + hpH + 5; var kiH = 14;
  // Candy icon (small lollipop)
  ctx.fillStyle = '#FF88CC';
  ctx.beginPath(); ctx.arc(hpX + 10, kiY + 7, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath(); ctx.arc(hpX + 10, kiY + 7, 6, 0, Math.PI); ctx.fill();
  ctx.fillStyle = '#FFAADD';
  ctx.fillRect(hpX + 9, kiY + 12, 3, 5);

  ctx.fillStyle = 'rgba(255, 230, 245, 0.5)';
  drawRoundedRect(ctx, barX, kiY, hpW, kiH, 3);
  ctx.fill();

  var kiPct = Math.max(0, player.ki / player.maxKi);
  var kiGrad = ctx.createLinearGradient(barX, kiY, barX, kiY + kiH);
  kiGrad.addColorStop(0, '#FF88DD');
  kiGrad.addColorStop(1, '#DD44AA');
  ctx.fillStyle = kiGrad;
  drawRoundedRect(ctx, barX, kiY, hpW * kiPct, kiH, 3);
  ctx.fill();

  if (kiPct >= 1) {
    ctx.save(); ctx.globalAlpha = 0.3 + Math.sin(gameAge * 6) * 0.2;
    ctx.fillStyle = '#FFCCEE';
    drawRoundedRect(ctx, barX, kiY, hpW, kiH, 3);
    ctx.fill();
    ctx.restore();
  }
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.lineWidth = 1;
  drawRoundedRect(ctx, barX, kiY, hpW, kiH, 3);
  ctx.stroke();

  // ---- Score panel (top-right) ----
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = 'rgba(60, 20, 40, 0.6)';
  drawRoundedRect(ctx, CANVAS_W - 220, 4, 214, 40, 10);
  ctx.fill();
  ctx.restore();

  // Score with star icon
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  var starCX = CANVAS_W - 206, starCY = 18;
  for (var si = 0; si < 5; si++) {
    var sa = si * Math.PI * 2 / 5 - Math.PI / 2;
    var sr = si === 0 ? 0 : 7;
    if (si === 0) ctx.moveTo(starCX + Math.cos(sa) * 7, starCY + Math.sin(sa) * 7);
    else ctx.lineTo(starCX + Math.cos(sa) * 7, starCY + Math.sin(sa) * 7);
    var sa2 = sa + Math.PI / 5;
    ctx.lineTo(starCX + Math.cos(sa2) * 3.5, starCY + Math.sin(sa2) * 3.5);
  }
  ctx.closePath(); ctx.fill();

  drawPixelTextWithShadow(ctx, '' + player.score, CANVAS_W - 192, 11, 2.5, COLORS.scoreGold);

  // Lives (hearts instead of goku heads for kid-friendliness)
  var lvX = CANVAS_W - 196; var lvY = 34;
  drawPixelText(ctx, 'LIVES', lvX, lvY, 1.5, '#FFAACC');
  for (var i = 0; i < player.lives; i++) {
    var hx = lvX + 45 + i * 18;
    // Heart shape
    ctx.fillStyle = '#FF4488';
    ctx.beginPath();
    ctx.moveTo(hx, lvY + 5);
    ctx.bezierCurveTo(hx, lvY + 1, hx - 6, lvY + 1, hx - 6, lvY + 5);
    ctx.bezierCurveTo(hx - 6, lvY + 9, hx, lvY + 12, hx, lvY + 12);
    ctx.bezierCurveTo(hx, lvY + 12, hx + 6, lvY + 9, hx + 6, lvY + 5);
    ctx.bezierCurveTo(hx + 6, lvY + 1, hx, lvY + 1, hx, lvY + 5);
    ctx.fill();
    // Shine on heart
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath(); ctx.arc(hx - 2, lvY + 4, 2, 0, Math.PI * 2); ctx.fill();
  }

  // Level indicator with candy stripe bar
  var levelLabel = 'LEVEL ' + (currentLevel + 1) + ' - ' + levelConfigs[currentLevel].name;
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = 'rgba(60, 20, 40, 0.5)';
  drawRoundedRect(ctx, 6, CANVAS_H - 24, getPixelTextWidth(levelLabel, 1.5) + 16, 20, 6);
  ctx.fill();
  ctx.restore();
  drawPixelText(ctx, levelLabel, 14, CANVAS_H - 20, 1.5, '#FFDDEE');

  // Controls guide (fades out after 6 seconds) - improved appearance
  if (levelTimer < 6) {
    var guideAlpha = levelTimer < 4 ? 0.8 : 0.8 * (1 - (levelTimer - 4) / 2);
    ctx.save();
    ctx.globalAlpha = guideAlpha;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    drawRoundedRect(ctx, CANVAS_W / 2 - 145, CANVAS_H - 56, 290, 48, 8);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 136, 204, 0.4)';
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, CANVAS_W / 2 - 145, CANVAS_H - 56, 290, 48, 8);
    ctx.stroke();
    ctx.globalAlpha = guideAlpha;
    drawPixelText(ctx, 'ARROWS:MOVE  Z:SHOOT  X:HIT', CANVAS_W / 2 - 130, CANVAS_H - 48, 1.5, '#FFFFFF');
    drawPixelText(ctx, 'C:BEAM  V:SUPER  ESC:PAUSE', CANVAS_W / 2 - 120, CANVAS_H - 30, 1.5, '#FFDDAA');
    ctx.restore();
  }

  // Tutorial overlay
  drawTutorial(ctx);
}

// ---- MENU SCREEN ----

function updateMenu(dt) {
  menuScrollX += dt * 30;
  gameAge += dt;
}

function drawMenu(ctx) {
  // Gradient background
  var bgGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  bgGrad.addColorStop(0, '#FFE0F0');
  bgGrad.addColorStop(0.5, '#FFD4E8');
  bgGrad.addColorStop(1, '#FFC8E0');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Floating candy background elements
  var candyBgColors = ['#FF88CC', '#88DDFF', '#FFEE66', '#88FF88', '#FFAA44', '#CC88FF'];
  for (var i = 0; i < 20; i++) {
    var cx = ((i * 97 + menuScrollX * 0.4 * ((i % 3) + 1) + i * i * 13) % (CANVAS_W + 80)) - 40;
    var cy = ((i * 67 + i * i * 5 + Math.sin(gameAge * 0.5 + i) * 30) % (CANVAS_H + 60)) - 30;
    var sz = 6 + (i % 4) * 3;
    ctx.save();
    ctx.globalAlpha = 0.2 + Math.sin(gameAge * 1.5 + i * 0.7) * 0.1;
    ctx.fillStyle = candyBgColors[i % candyBgColors.length];
    ctx.translate(cx, cy);
    ctx.rotate(gameAge * 0.3 + i);
    // Alternate shapes
    if (i % 3 === 0) {
      // Star
      ctx.beginPath();
      for (var s = 0; s < 5; s++) {
        var sa = s * Math.PI * 2 / 5 - Math.PI / 2;
        if (s === 0) ctx.moveTo(Math.cos(sa) * sz, Math.sin(sa) * sz);
        else ctx.lineTo(Math.cos(sa) * sz, Math.sin(sa) * sz);
        var sa2 = sa + Math.PI / 5;
        ctx.lineTo(Math.cos(sa2) * sz * 0.4, Math.sin(sa2) * sz * 0.4);
      }
      ctx.closePath(); ctx.fill();
    } else if (i % 3 === 1) {
      // Circle (candy)
      ctx.beginPath(); ctx.arc(0, 0, sz, 0, Math.PI * 2); ctx.fill();
    } else {
      // Diamond
      ctx.beginPath();
      ctx.moveTo(0, -sz); ctx.lineTo(sz * 0.6, 0); ctx.lineTo(0, sz); ctx.lineTo(-sz * 0.6, 0);
      ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  // Golden sprinkles
  ctx.fillStyle = '#FFD700';
  for (var i = 0; i < 60; i++) {
    var sx = (i * 53 + menuScrollX * 0.3 + i*i*7) % CANVAS_W;
    var sy = (i * 37 + i*i*3) % CANVAS_H;
    ctx.globalAlpha = 0.25 + Math.sin(gameAge * 2 + i) * 0.2;
    ctx.fillRect(sx, sy, (i%3===0)?2:1, (i%3===0)?2:1);
  }
  ctx.globalAlpha = 1;

  // Title glow (pulsing)
  ctx.save();
  var glowSize = 180 + Math.sin(gameAge * 2) * 30;
  ctx.globalAlpha = 0.12 + Math.sin(gameAge * 1.5) * 0.06;
  var titleGlow = ctx.createRadialGradient(CANVAS_W/2, 115, 0, CANVAS_W/2, 115, glowSize);
  titleGlow.addColorStop(0, '#FF88CC');
  titleGlow.addColorStop(0.6, '#FFAADD');
  titleGlow.addColorStop(1, 'rgba(255, 136, 204, 0)');
  ctx.fillStyle = titleGlow;
  ctx.beginPath(); ctx.arc(CANVAS_W/2, 115, glowSize, 0, Math.PI * 2); ctx.fill();
  ctx.restore();

  // Title with bounce effect
  var titleBounce = Math.sin(gameAge * 2) * 3;
  drawPixelTextCenteredWithShadow(ctx, 'GOKUS', CANVAS_W/2, 65 + titleBounce, 6, '#FFD700', '#884400');
  drawPixelTextCenteredWithShadow(ctx, 'CANDY RIDER', CANVAS_W/2, 118 + titleBounce * 0.5, 5, '#FF8800', '#662200');

  // Animated Goku on cloud (larger, more detailed)
  ctx.save();
  var gokuX = CANVAS_W/2 - 20 + Math.sin(gameAge * 1.8) * 15;
  var gokuY = 220 + Math.sin(gameAge * 2.5) * 10;
  ctx.translate(gokuX, gokuY);
  // Cloud trail particles (candy sparkle)
  for (var i = 0; i < 5; i++) {
    ctx.globalAlpha = 0.15 + Math.sin(gameAge * 3 + i * 1.2) * 0.1;
    ctx.fillStyle = ['#FFD700', '#FFEE88', '#FFFFCC'][i % 3];
    ctx.beginPath();
    ctx.arc(-15 - i * 12 + Math.sin(gameAge * 2 + i) * 4, 10 + Math.cos(gameAge * 1.5 + i) * 3, 5 - i * 0.7, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  // Nimbus cloud (bigger)
  ctx.fillStyle = '#FFC107';
  ctx.beginPath(); ctx.ellipse(0, 12, 34, 12, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFD54F';
  ctx.beginPath(); ctx.ellipse(-10, 10, 18, 9, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(12, 10, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFECB3';
  ctx.beginPath(); ctx.ellipse(-4, 6, 16, 8, 0, 0, Math.PI * 2); ctx.fill();
  // Goku body
  ctx.fillStyle = '#FF8C00';
  ctx.fillRect(-10, -22, 20, 22);
  ctx.fillStyle = '#F57C00';
  ctx.fillRect(-10, -22, 4, 22);
  // Belt
  ctx.fillStyle = '#1E88E5';
  ctx.fillRect(-11, -4, 22, 4);
  // Head
  ctx.fillStyle = '#FFD699';
  ctx.beginPath(); ctx.arc(0, -30, 10, 0, Math.PI * 2); ctx.fill();
  // Eyes
  ctx.fillStyle = '#FFF';
  ctx.fillRect(-5, -33, 4, 4);
  ctx.fillRect(2, -33, 4, 4);
  ctx.fillStyle = '#000';
  ctx.fillRect(-4, -32, 2, 3);
  ctx.fillRect(3, -32, 2, 3);
  // Smile
  ctx.strokeStyle = '#FFC266';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, -26, 4, 0.2, Math.PI - 0.2);
  ctx.stroke();
  // Hair
  ctx.fillStyle = '#1A1A1A';
  ctx.beginPath();
  ctx.arc(0, -31, 12, Math.PI, 2 * Math.PI); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-3, -42); ctx.lineTo(1, -56); ctx.lineTo(6, -42); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(4, -41); ctx.lineTo(13, -52); ctx.lineTo(11, -38); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-7, -40); ctx.lineTo(-8, -50); ctx.lineTo(-1, -41); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(9, -37); ctx.lineTo(18, -43); ctx.lineTo(13, -34); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-11, -37); ctx.lineTo(-15, -44); ctx.lineTo(-7, -38); ctx.fill();
  ctx.restore();

  // ---- Menu Options ----
  var optionY = 310;

  // Start button
  var startSelected = (menuSelection === 0);
  if (startSelected) {
    ctx.save();
    ctx.globalAlpha = 0.15 + Math.sin(gameAge * 4) * 0.05;
    ctx.fillStyle = '#FFFFFF';
    drawRoundedRect(ctx, CANVAS_W/2 - 140, optionY - 6, 280, 30, 8);
    ctx.fill();
    ctx.restore();
  }
  var startBlink = startSelected ? (Math.sin(gameAge * 3) > -0.3 ? 1 : 0.6) : 0.7;
  ctx.save(); ctx.globalAlpha = startBlink;
  drawPixelTextCenteredWithShadow(ctx, 'PRESS ENTER TO START', CANVAS_W/2, optionY, 3, startSelected ? '#FFFFFF' : '#DDBBCC');
  ctx.restore();

  // Difficulty selector
  var diffY = optionY + 42;
  var diffSelected = (menuSelection === 1);
  var diffLabel = difficultyMultipliers[currentDifficulty].label;

  if (diffSelected) {
    ctx.save();
    ctx.globalAlpha = 0.15 + Math.sin(gameAge * 4) * 0.05;
    ctx.fillStyle = '#FFFFFF';
    drawRoundedRect(ctx, CANVAS_W/2 - 130, diffY - 4, 260, 24, 6);
    ctx.fill();
    ctx.restore();
  }

  // Draw difficulty options
  var diffColors = ['#44DD66', '#FFBB33', '#FF4466'];
  drawPixelTextCentered(ctx, 'DIFFICULTY:', CANVAS_W/2 - 70, diffY, 2, diffSelected ? '#FFFFFF' : '#AA8899');
  // Left arrow
  drawPixelText(ctx, '<', CANVAS_W/2 + 10, diffY, 2, diffSelected ? '#FFFFFF' : '#AA8899');
  // Difficulty value
  drawPixelText(ctx, diffLabel, CANVAS_W/2 + 28, diffY, 2, diffColors[currentDifficulty]);
  // Right arrow
  var diffLabelWidth = getPixelTextWidth(diffLabel, 2);
  drawPixelText(ctx, '>', CANVAS_W/2 + 36 + diffLabelWidth, diffY, 2, diffSelected ? '#FFFFFF' : '#AA8899');

  // Navigation hint
  drawPixelTextCentered(ctx, 'UP/DOWN:SELECT  LEFT/RIGHT:CHANGE', CANVAS_W/2, diffY + 28, 1.5, '#AA8899');

  // Controls info (improved)
  var ctrlY = diffY + 52;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  drawRoundedRect(ctx, CANVAS_W/2 - 200, ctrlY - 4, 400, 42, 8);
  ctx.fill();
  ctx.restore();
  drawPixelTextCentered(ctx, 'ARROWS:MOVE  Z:SHOOT  X:MELEE', CANVAS_W/2, ctrlY, 2, '#CCAABB');
  drawPixelTextCentered(ctx, 'C:RAINBOW BEAM  V:SPIRIT BOMB  ESC:PAUSE', CANVAS_W/2, ctrlY + 18, 2, '#CCAABB');

  // High score
  if (highScore > 0) {
    drawPixelTextCentered(ctx, 'HIGH SCORE: ' + highScore, CANVAS_W/2, ctrlY + 48, 2.5, '#FFD700');
  }

  drawPixelTextCentered(ctx, 'CANDY LAND ARCADE', CANVAS_W/2, CANVAS_H - 16, 1, '#998888');
}

// ---- LEVEL INTRO SCREEN ----

function updateIntro(dt) {
  introTimer += dt;
  gameAge += dt;
}

function drawLevelIntro(ctx) {
  // Gradient background based on level
  var bgColors = [
    ['#FFE0F0', '#FFD4E8'], // Level 1 - pink
    ['#FFEEDD', '#FFDDBB'], // Level 2 - warm
    ['#EEEEFF', '#DDEEFF']  // Level 3 - crystal
  ];
  var bgc = bgColors[currentLevel] || bgColors[0];
  var bgGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  bgGrad.addColorStop(0, bgc[0]);
  bgGrad.addColorStop(1, bgc[1]);
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Animated sparkles
  var sparkleColors = ['#FFD700', '#FF88CC', '#88DDFF', '#88FF88'];
  for (var i = 0; i < 30; i++) {
    var sx = (i * 83 + gameAge * 20 * ((i % 3) + 1)) % CANVAS_W;
    var sy = (i * 47 + i * i * 3) % CANVAS_H;
    ctx.globalAlpha = 0.3 + Math.sin(gameAge * 3 + i * 1.3) * 0.25;
    ctx.fillStyle = sparkleColors[i % sparkleColors.length];
    ctx.beginPath(); ctx.arc(sx, sy, 2 + (i % 3), 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Level number with zoom effect
  var introProgress = Math.min(1, introTimer / 0.8);
  var levelScale = 6 + (1 - introProgress) * 4;
  ctx.save();
  ctx.globalAlpha = introProgress;
  drawPixelTextCenteredWithShadow(ctx, 'LEVEL ' + (currentLevel + 1), CANVAS_W/2, 140, levelScale, '#FFFFFF', '#884466');
  ctx.restore();

  // Level name
  var cfg = levelConfigs[currentLevel];
  if (introTimer > 0.4) {
    var nameAlpha = Math.min(1, (introTimer - 0.4) / 0.5);
    ctx.save(); ctx.globalAlpha = nameAlpha;
    drawPixelTextCenteredWithShadow(ctx, cfg.name, CANVAS_W/2, 210, 4, '#FFD700', '#663300');
    drawPixelTextCenteredWithShadow(ctx, cfg.subtitle, CANVAS_W/2, 255, 3, '#FF8800', '#442200');
    ctx.restore();
  }

  // Countdown
  var count = Math.ceil(introCountdown - introTimer);
  if (count > 0 && count <= 3) {
    var countPulse = 1 + Math.sin(introTimer * 10) * 0.1;
    drawPixelTextCenteredWithShadow(ctx, '' + count, CANVAS_W/2, 340, 8 * countPulse, '#FF6688', '#993355');
  } else if (introTimer > introCountdown - 0.5) {
    var fightPulse = 1 + (introCountdown - introTimer) * 2;
    drawPixelTextCenteredWithShadow(ctx, 'FIGHT!', CANVAS_W/2, 335, 7 * fightPulse, '#FF4488', '#993355');
    if (introTimer > introCountdown - 0.45 && introTimer < introCountdown - 0.4) {
      flash('#FF88CC', 0.2);
    }
  }
}

// ---- GAME OVER ----

function drawGameOver(ctx) {
  // Dimmed background with vignette
  ctx.fillStyle = 'rgba(80, 20, 40, 0.85)';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Central panel
  ctx.save();
  ctx.fillStyle = 'rgba(255, 200, 220, 0.9)';
  drawRoundedRect(ctx, CANVAS_W/2 - 200, 120, 400, 300, 20);
  ctx.fill();
  ctx.strokeStyle = '#FF88CC';
  ctx.lineWidth = 3;
  drawRoundedRect(ctx, CANVAS_W/2 - 200, 120, 400, 300, 20);
  ctx.stroke();
  ctx.restore();

  drawPixelTextCenteredWithShadow(ctx, 'GAME OVER', CANVAS_W/2, 155, 6, '#FF4488', '#993355');

  // Divider
  ctx.strokeStyle = '#FFAACC';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(CANVAS_W/2 - 140, 200); ctx.lineTo(CANVAS_W/2 + 140, 200); ctx.stroke();

  if (player) {
    drawPixelTextCenteredWithShadow(ctx, 'SCORE: ' + player.score, CANVAS_W/2, 230, 4, '#FFD700', '#884400');
    // New high score indicator
    if (player.score >= highScore && player.score > 0) {
      var newHsAlpha = 0.7 + Math.sin(gameAge * 5) * 0.3;
      ctx.save(); ctx.globalAlpha = newHsAlpha;
      drawPixelTextCentered(ctx, 'NEW HIGH SCORE!', CANVAS_W/2, 275, 2.5, '#FFD700');
      ctx.restore();
    }
  }
  if (highScore > 0) {
    drawPixelTextCentered(ctx, 'BEST: ' + highScore, CANVAS_W/2, 300, 2.5, '#FFAA88');
  }
  // Difficulty indicator
  drawPixelTextCentered(ctx, 'DIFFICULTY: ' + difficultyMultipliers[currentDifficulty].label, CANVAS_W/2, 330, 2, '#AA7799');

  if (Math.sin(gameAge * 3) > -0.3) {
    drawPixelTextCentered(ctx, 'PRESS ENTER OR SPACE', CANVAS_W/2, 370, 2.5, '#FFFFFF');
  }
}

// ---- VICTORY ----

function drawVictory(ctx) {
  // Golden gradient background
  var vGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
  vGrad.addColorStop(0, 'rgba(255, 250, 230, 0.95)');
  vGrad.addColorStop(0.5, 'rgba(255, 240, 200, 0.95)');
  vGrad.addColorStop(1, 'rgba(255, 230, 180, 0.95)');
  ctx.fillStyle = vGrad;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Multiple golden glow layers
  ctx.save();
  ctx.globalAlpha = 0.15 + Math.sin(gameAge * 2) * 0.08;
  var gGrad = ctx.createRadialGradient(CANVAS_W/2, 180, 0, CANVAS_W/2, 180, 200);
  gGrad.addColorStop(0, '#FFD700');
  gGrad.addColorStop(0.5, '#FFAA44');
  gGrad.addColorStop(1, 'rgba(255, 170, 0, 0)');
  ctx.fillStyle = gGrad;
  ctx.beginPath(); ctx.arc(CANVAS_W/2, 180, 200, 0, Math.PI * 2); ctx.fill();
  ctx.restore();

  // Rainbow rays
  ctx.save();
  ctx.globalAlpha = 0.06;
  var rayColors = ['#FF6666', '#FFAA44', '#FFEE44', '#66DD88', '#66AAFF', '#CC88FF'];
  for (var i = 0; i < rayColors.length; i++) {
    var rayAngle = (i / rayColors.length) * Math.PI * 2 + gameAge * 0.2;
    ctx.fillStyle = rayColors[i];
    ctx.beginPath();
    ctx.moveTo(CANVAS_W/2, 180);
    ctx.lineTo(CANVAS_W/2 + Math.cos(rayAngle) * 400, 180 + Math.sin(rayAngle) * 400);
    ctx.lineTo(CANVAS_W/2 + Math.cos(rayAngle + 0.3) * 400, 180 + Math.sin(rayAngle + 0.3) * 400);
    ctx.closePath(); ctx.fill();
  }
  ctx.restore();

  drawPixelTextCenteredWithShadow(ctx, 'VICTORY!', CANVAS_W/2, 120, 7, '#FFD700', '#664400');

  // Stars around title
  ctx.fillStyle = '#FFD700';
  for (var i = 0; i < 8; i++) {
    var sAngle = (i / 8) * Math.PI * 2 + gameAge;
    var sR = 100 + Math.sin(gameAge * 2 + i) * 20;
    var sx = CANVAS_W/2 + Math.cos(sAngle) * sR;
    var sy = 140 + Math.sin(sAngle) * sR * 0.3;
    ctx.globalAlpha = 0.5 + Math.sin(gameAge * 3 + i) * 0.3;
    ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  if (player) {
    drawPixelTextCenteredWithShadow(ctx, 'FINAL SCORE: ' + player.score, CANVAS_W/2, 220, 4, '#FFFFFF', '#664400');
  }
  drawPixelTextCentered(ctx, 'YOU SAVED CANDY LAND!', CANVAS_W/2, 280, 3, '#FF8844');
  drawPixelTextCentered(ctx, 'ALL SWEETS ARE SAFE!', CANVAS_W/2, 310, 2.5, '#FFAA66');

  if (Math.sin(gameAge * 3) > -0.3) {
    drawPixelTextCentered(ctx, 'PRESS ENTER OR SPACE', CANVAS_W/2, 380, 3, '#FFFFFF');
  }
  // Victory confetti particles
  if (Math.random() < 0.2) {
    var confettiColors = ['#FFD700', '#FF8800', '#FFEE44', '#FF66AA', '#66DDFF', '#88FF88'];
    spawnParticles(rand(0, CANVAS_W), rand(0, CANVAS_H * 0.6), 3,
      confettiColors[randInt(0, confettiColors.length - 1)], 15, 40, 1.2, 4);
  }
}

// ---- LEVEL COMPLETE ----

function drawLevelComplete(ctx) {
  ctx.fillStyle = 'rgba(255, 220, 240, 0.85)';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Celebration panel
  ctx.save();
  ctx.fillStyle = 'rgba(255, 245, 250, 0.9)';
  drawRoundedRect(ctx, CANVAS_W/2 - 200, 140, 400, 260, 16);
  ctx.fill();
  ctx.strokeStyle = '#FF88CC';
  ctx.lineWidth = 3;
  drawRoundedRect(ctx, CANVAS_W/2 - 200, 140, 400, 260, 16);
  ctx.stroke();
  ctx.restore();

  // Animated stars
  for (var i = 0; i < 3; i++) {
    var starAngle = gameAge * 2 + i * 2.1;
    var starX = CANVAS_W/2 - 60 + i * 60;
    var starY = 170 + Math.sin(starAngle) * 5;
    ctx.fillStyle = '#FFD700';
    ctx.save(); ctx.translate(starX, starY); ctx.rotate(starAngle * 0.5);
    ctx.beginPath();
    for (var s = 0; s < 5; s++) {
      var sa = s * Math.PI * 2 / 5 - Math.PI / 2;
      if (s === 0) ctx.moveTo(Math.cos(sa) * 12, Math.sin(sa) * 12);
      else ctx.lineTo(Math.cos(sa) * 12, Math.sin(sa) * 12);
      var sa2 = sa + Math.PI / 5;
      ctx.lineTo(Math.cos(sa2) * 5, Math.sin(sa2) * 5);
    }
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  drawPixelTextCenteredWithShadow(ctx, 'LEVEL COMPLETE!', CANVAS_W/2, 200, 4.5, '#FF88CC', '#993366');

  if (player) {
    drawPixelTextCenteredWithShadow(ctx, 'SCORE: ' + player.score, CANVAS_W/2, 255, 3.5, '#FFD700', '#884400');
  }

  // Next level preview
  if (currentLevel < levelConfigs.length - 1) {
    drawPixelTextCentered(ctx, 'NEXT: ' + levelConfigs[currentLevel + 1].name, CANVAS_W/2, 300, 2, '#AA7799');
  } else {
    drawPixelTextCentered(ctx, 'FINAL BOSS DEFEATED!', CANVAS_W/2, 300, 2, '#FFD700');
  }

  if (levelCompleteTimer > 2 && Math.sin(gameAge * 3) > -0.3) {
    drawPixelTextCentered(ctx, 'PRESS ENTER OR SPACE', CANVAS_W/2, 360, 2.5, '#FFFFFF');
  }

  // Confetti
  if (Math.random() < 0.12) {
    spawnParticles(rand(CANVAS_W/2 - 150, CANVAS_W/2 + 150), 130, 2,
      ['#FFD700', '#FF88CC', '#88DDFF'][randInt(0, 2)], 10, 30, 0.8, 3);
  }
}

// ---- COLLISION DETECTION ----

function checkCollisions() {
  if (!player || player.state === 'dead') return;
  // Player projectiles vs enemies
  for (var p = projectiles.length - 1; p >= 0; p--) {
    var proj = projectiles[p];
    if (!proj.alive) continue;
    // vs enemies
    for (var e = 0; e < enemies.length; e++) {
      var en = enemies[e];
      if (!en.alive) continue;
      if (proj instanceof KiBlast) {
        if (aabb(proj, en)) {
          en.takeDamage(proj.damage); proj.alive = false;
          spawnParticles(proj.x, proj.y, 5, COLORS.kiBlue, 5, 30, 0.3, 3);
        }
      } else if (proj instanceof KamehamehaBeam) {
        var hb = proj.getHitbox();
        if (hb && aabb(hb, en)) {
          en.takeDamage(proj.damage);
        }
      } else if (proj instanceof SpiritBomb) {
        if (aabb(proj, en) && !proj.hitTargets.has(en)) {
          en.takeDamage(proj.damage);
          proj.hitTargets.add(en);
        }
      }
    }
    // vs bosses
    for (var b = 0; b < bosses.length; b++) {
      var boss = bosses[b];
      if (!boss.alive || boss.defeated || boss.enteringScene) continue;
      if (proj instanceof KiBlast) {
        if (aabb(proj, boss)) {
          boss.takeDamage(proj.damage); proj.alive = false;
          spawnParticles(proj.x, proj.y, 5, COLORS.kiBlue, 5, 30, 0.3, 3);
        }
      } else if (proj instanceof KamehamehaBeam) {
        var hb = proj.getHitbox();
        if (hb && aabb(hb, boss)) {
          boss.takeDamage(proj.damage);
        }
      } else if (proj instanceof SpiritBomb) {
        if (aabb(proj, boss) && !proj.hitTargets.has(boss)) {
          boss.takeDamage(proj.damage);
          proj.hitTargets.add(boss);
        }
      }
    }
  }
  // Player melee hitbox
  var mhb = player.getMeleeHitbox();
  if (mhb) {
    for (var e = 0; e < enemies.length; e++) {
      if (enemies[e].alive && aabb(mhb, enemies[e])) {
        enemies[e].takeDamage(15);
        spawnParticles(enemies[e].x + enemies[e].w / 2, enemies[e].y + enemies[e].h / 2, 4, COLORS.explosionOrange, 5, 20, 0.3, 3);
      }
    }
    for (var b = 0; b < bosses.length; b++) {
      if (bosses[b].alive && !bosses[b].defeated && aabb(mhb, bosses[b])) {
        bosses[b].takeDamage(15);
        spawnParticles(bosses[b].x + bosses[b].w / 2, bosses[b].y + bosses[b].h / 2, 4, COLORS.explosionOrange, 5, 20, 0.3, 3);
      }
    }
  }
  // Enemy projectiles vs player
  if (!player.invincible) {
    for (var p = enemyProjectiles.length - 1; p >= 0; p--) {
      var ep = enemyProjectiles[p];
      if (!ep.alive) continue;
      if (aabb({x: ep.x - ep.size, y: ep.y - ep.size, w: ep.size*2, h: ep.size*2}, player)) {
        player.takeDamage(ep.damage);
        ep.alive = false;
        spawnExplosion(ep.x, ep.y, 1);
      }
    }
    // Enemy body vs player
    for (var e = 0; e < enemies.length; e++) {
      var en = enemies[e];
      if (en.alive && aabb(en, player)) {
        player.takeDamage(10);
        en.takeDamage(5);
      }
    }
  }
  // Player vs powerups
  for (var p = powerUps.length - 1; p >= 0; p--) {
    var pu = powerUps[p];
    if (!pu.alive) continue;
    if (aabb(pu, player)) {
      pu.alive = false;
      playSound('powerup');
      switch(pu.type) {
        case 'senzu': player.hp = Math.min(player.maxHp, player.hp + 30); break;
        case 'ki': player.ki = Math.min(player.maxKi, player.ki + 35); break;
        case 'dragonball': player.lives++; break;
        case 'speed': player.speedBoostTimer = 5; break;
      }
      spawnPowerUpCollect(pu.x + 12, pu.y + 12, pu.type);
      // Floating text feedback
      var puLabel = {senzu: '+HP', ki: '+CANDY', dragonball: '+1 LIFE', speed: 'SPEED UP!'}[pu.type] || 'YAY!';
      var puColor = {senzu: '#FF88AA', ki: '#FF44AA', dragonball: '#FFD700', speed: '#FFAADD'}[pu.type] || '#FFFFFF';
      spawnFloatingText(pu.x + 12, pu.y - 10, puLabel, puColor, 2.5);
    }
  }
}

// ---- SPAWN ENEMIES ----

function spawnEnemiesForLevel(dt) {
  var cfg = levelConfigs[currentLevel];
  if (!cfg) return;
  while (spawnIndex < cfg.spawns.length && cfg.spawns[spawnIndex].t <= levelTimer) {
    var s = cfg.spawns[spawnIndex];
    var EClass = enemyClasses[s.type];
    if (EClass) {
      var diff = difficultyMultipliers[currentDifficulty];
      for (var i = 0; i < s.count; i++) {
        var ex = CANVAS_W + 20 + i * 40;
        var ey = rand(s.yMin, s.yMax);
        var en = new EClass(ex, ey);
        en.hp = Math.floor(en.hp * diff.enemyHp);
        en.maxHp = en.hp;
        en.speed = en.speed * diff.enemySpeed;
        enemies.push(en);
      }
    }
    spawnIndex++;
  }
}

// ---- MAIN GAME FUNCTIONS ----

function startGame() {
  player = new Player();
  // Apply difficulty settings
  var diff = difficultyMultipliers[currentDifficulty];
  player.maxHp = diff.playerHp;
  player.hp = diff.playerHp;
  player.kiRegenRate = diff.playerKiRegen;
  currentLevel = 0;
  gameState = STATE.LEVEL_INTRO;
  startLevel(0);
  // Reset tutorial for new game
  if (showTutorial) {
    tutorialStep = 0;
    tutorialTimer = 0;
  }
}

function startLevel(idx) {
  currentLevel = idx;
  levelTimer = 0; levelScrollX = 0; spawnIndex = 0;
  bossActive = false; bossTriggered = false;
  enemies.length = 0; bosses.length = 0;
  enemyProjectiles.length = 0; projectiles.length = 0;
  powerUps.length = 0; particles.length = 0;
  introTimer = 0;
  gameState = STATE.LEVEL_INTRO;
  if (player) {
    player.x = 80; player.y = CANVAS_H / 2;
    player.hp = player.maxHp;
    player.ki = 0;
    player.state = 'idle';
    player.invincible = true; player.invincibleTimer = 2;
    player.projectiles.length = 0;
    player.chargingKame = false;
    player.kameFiring = false;
  }
}

function updateGame(dt) {
  gameAge += dt;
  levelTimer += dt;
  levelScrollX += SCROLL_SPEED * dt;
  // spawn enemies
  if (!bossTriggered) {
    spawnEnemiesForLevel(dt);
    var cfg = levelConfigs[currentLevel];
    if (cfg && levelTimer >= cfg.duration) {
      // check if all enemies dead
      var allDead = true;
      for (var i = 0; i < enemies.length; i++) {
        if (enemies[i].alive) { allDead = false; break; }
      }
      if (allDead || levelTimer > cfg.duration + 5) {
        bossTriggered = true;
        bossActive = true;
        var BossClass = cfg.bossClass;
        bosses.push(new BossClass());
        playSound('bossIntro');
        gameState = STATE.BOSS_FIGHT;
      }
    }
  }
  // update player
  if (player) player.update(dt);
  // update projectiles
  for (var i = projectiles.length - 1; i >= 0; i--) {
    projectiles[i].update(dt);
    if (!projectiles[i].alive) projectiles.splice(i, 1);
  }
  // update enemies
  for (var i = enemies.length - 1; i >= 0; i--) {
    enemies[i].update(dt);
    if (!enemies[i].alive) enemies.splice(i, 1);
  }
  // update bosses
  for (var i = bosses.length - 1; i >= 0; i--) {
    bosses[i].update(dt);
    if (!bosses[i].alive) {
      bosses.splice(i, 1);
      // boss defeated!
      if (bosses.length === 0 && bossActive) {
        bossActive = false;
        playSound('levelComplete');
        levelCompleteTimer = 0;
        gameState = STATE.LEVEL_COMPLETE;
      }
    }
  }
  // update enemy projectiles
  for (var i = enemyProjectiles.length - 1; i >= 0; i--) {
    enemyProjectiles[i].update(dt);
    if (!enemyProjectiles[i].alive) enemyProjectiles.splice(i, 1);
  }
  // update powerups
  for (var i = powerUps.length - 1; i >= 0; i--) {
    powerUps[i].update(dt);
    if (!powerUps[i].alive) powerUps.splice(i, 1);
  }
  // particles
  updateParticles(dt);
  // floating texts
  updateFloatingTexts(dt);
  // flash
  updateFlash(dt);
  // camera
  updateCamera(dt);
  // input just pressed
  updateInputJustPressed();
  // collisions
  checkCollisions();
  // check game over
  if (player && player.lives <= 0 && player.state === 'dead') {
    gameState = STATE.GAME_OVER;
    playSound('gameOver');
    if (player.score > highScore) {
      highScore = player.score;
      localStorage.setItem('gokuHighScore', highScore);
    }
  }
}

function drawGame(ctx) {
  // background
  drawLevelBackground(ctx, currentLevel, levelScrollX, gameAge);
  // apply camera
  ctx.save();
  applyCameraTransform(ctx);
  // powerups
  for (var i = 0; i < powerUps.length; i++) powerUps[i].draw(ctx);
  // enemies
  for (var i = 0; i < enemies.length; i++) enemies[i].draw(ctx);
  // bosses
  for (var i = 0; i < bosses.length; i++) bosses[i].draw(ctx);
  // player
  if (player) player.draw(ctx);
  // projectiles
  for (var i = 0; i < projectiles.length; i++) projectiles[i].draw(ctx);
  // enemy projectiles
  for (var i = 0; i < enemyProjectiles.length; i++) enemyProjectiles[i].draw(ctx);
  // particles
  drawParticles(ctx);
  // floating texts
  drawFloatingTexts(ctx);
  ctx.restore();
  resetCameraTransform(ctx);
  // HUD
  drawHUD(ctx);
  // touch controls
  drawTouchControls(ctx);
  // flash
  drawFlash(ctx);
}

// ---- ENTER KEY HANDLER ----

window.addEventListener('keydown', function(e) {
  // Menu navigation with arrow keys
  if (gameState === STATE.MENU) {
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      menuSelection = menuSelection === 0 ? 1 : 0;
      playSound('kiBlast');
      e.preventDefault();
      return;
    }
    if (menuSelection === 1 && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
      if (e.key === 'ArrowLeft') currentDifficulty = Math.max(0, currentDifficulty - 1);
      if (e.key === 'ArrowRight') currentDifficulty = Math.min(2, currentDifficulty + 1);
      playSound('kiBlast');
      e.preventDefault();
      return;
    }
  }

  // Enter or Space for confirmations
  if (e.key === 'Enter' || e.key === ' ') {
    initAudioContext();
    if (e.key === ' ' && (gameState === STATE.PLAYING || gameState === STATE.BOSS_FIGHT)) return;
    e.preventDefault();
    switch(gameState) {
      case STATE.MENU:
        if (menuSelection === 0) {
          startTransition(function() { startGame(); });
        }
        break;
      case STATE.PAUSED:
        // Enter from pause goes to menu
        if (e.key === 'Enter') {
          startTransition(function() { gameState = STATE.MENU; menuSelection = 0; });
        }
        break;
      case STATE.GAME_OVER:
        startTransition(function() { gameState = STATE.MENU; menuSelection = 0; });
        break;
      case STATE.VICTORY:
        startTransition(function() { gameState = STATE.MENU; menuSelection = 0; });
        break;
      case STATE.LEVEL_COMPLETE:
        if (levelCompleteTimer > 2) {
          if (currentLevel < levelConfigs.length - 1) {
            startTransition(function() { startLevel(currentLevel + 1); });
          } else {
            startTransition(function() {
              gameState = STATE.VICTORY;
              playSound('levelComplete');
              if (player && player.score > highScore) {
                highScore = player.score;
                localStorage.setItem('gokuHighScore', highScore);
              }
            });
          }
        }
        break;
    }
  }
});

// Touch tap on canvas for menu start
window.addEventListener('touchstart', function(e) {
  if (gameState === STATE.MENU || gameState === STATE.GAME_OVER || gameState === STATE.VICTORY) {
    initAudioContext();
  }
  if (gameState === STATE.MENU) {
    // Tap anywhere except difficulty row to start
    var touch = e.changedTouches[0];
    if (touch) {
      var canvas = document.getElementById('gameCanvas');
      var rect = canvas.getBoundingClientRect();
      var ty = (touch.clientY - rect.top) / (rect.height / CANVAS_H);
      if (ty < 340) {
        startTransition(function() { startGame(); });
      }
    }
  }
}, { passive: true });

// ---- MAIN LOOP ----

var lastTime = 0;

function gameLoop(timestamp) {
  var dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

  // Update transitions
  updateTransition(dt);

  switch(gameState) {
    case STATE.MENU:
      updateMenu(dt);
      drawMenu(ctx);
      break;
    case STATE.LEVEL_INTRO:
      updateIntro(dt);
      drawLevelIntro(ctx);
      if (introTimer >= introCountdown) {
        gameState = STATE.PLAYING;
      }
      break;
    case STATE.PLAYING:
    case STATE.BOSS_FIGHT:
      updateGame(dt);
      updateTutorial(dt);
      drawGame(ctx);
      break;
    case STATE.PAUSED:
      // Draw frozen game underneath
      drawGame(ctx);
      drawPauseScreen(ctx);
      break;
    case STATE.LEVEL_COMPLETE:
      levelCompleteTimer += dt;
      gameAge += dt;
      updateParticles(dt);
      updateFlash(dt);
      drawGame(ctx);
      drawLevelComplete(ctx);
      drawParticles(ctx);
      drawFlash(ctx);
      break;
    case STATE.GAME_OVER:
      gameAge += dt;
      updateParticles(dt);
      drawGame(ctx);
      drawGameOver(ctx);
      break;
    case STATE.VICTORY:
      gameAge += dt;
      updateParticles(dt);
      drawVictory(ctx);
      drawParticles(ctx);
      break;
  }

  // Draw screen transition overlay on top of everything
  drawTransition(ctx);

  requestAnimationFrame(gameLoop);
}

// ---- INITIALIZATION ----

var canvas = document.getElementById('gameCanvas');
var ctx = canvas.getContext('2d');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;

// Disable image smoothing for pixel art
ctx.imageSmoothingEnabled = false;

function resizeCanvas() {
  var scale = Math.min(window.innerWidth / CANVAS_W, window.innerHeight / CANVAS_H);
  canvas.style.width = (CANVAS_W * scale) + 'px';
  canvas.style.height = (CANVAS_H * scale) + 'px';
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Detect touch device
if ('ontouchstart' in window) {
  initTouchControls(canvas);
}

// Start!
requestAnimationFrame(gameLoop);

// === END LEVELS, UI, AND GAME LOOP ===
  </script>
</body>
</html>
