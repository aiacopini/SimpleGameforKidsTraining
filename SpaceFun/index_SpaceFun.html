<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NOVA STRIKE ‚Äî Space Shooter</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Rajdhani', sans-serif;
  }

  #gameContainer {
    position: relative;
    width: 800px;
    height: 600px;
  }

  canvas {
    display: block;
    border: 2px solid rgba(0, 255, 200, 0.3);
    border-radius: 4px;
    box-shadow: 0 0 40px rgba(0, 255, 200, 0.1), inset 0 0 40px rgba(0, 0, 0, 0.5);
  }

  #hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    padding: 12px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
    z-index: 10;
  }

  .hud-section {
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .hud-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: rgba(0, 255, 200, 0.6);
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .hud-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    color: #00ffc8;
    text-shadow: 0 0 10px rgba(0, 255, 200, 0.5);
  }

  .health-bar {
    width: 150px;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid rgba(0, 255, 200, 0.3);
  }

  .health-fill {
    height: 100%;
    background: linear-gradient(90deg, #00ffc8, #00ff88);
    border-radius: 4px;
    transition: width 0.3s;
    box-shadow: 0 0 10px rgba(0, 255, 200, 0.5);
  }

  #livesDisplay {
    display: flex;
    gap: 6px;
  }

  .life-icon {
    width: 0; height: 0;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;
    border-bottom: 14px solid #00ffc8;
    filter: drop-shadow(0 0 4px rgba(0,255,200,0.6));
    opacity: 1;
    transition: opacity 0.3s;
  }

  .life-icon.lost { opacity: 0.15; }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.85);
    z-index: 20;
    backdrop-filter: blur(5px);
  }

  #overlay.hidden { display: none; }

  .title {
    font-family: 'Orbitron', sans-serif;
    font-size: 56px;
    font-weight: 900;
    color: #00ffc8;
    text-shadow: 0 0 30px rgba(0, 255, 200, 0.5), 0 0 60px rgba(0, 255, 200, 0.2);
    letter-spacing: 8px;
    margin-bottom: 10px;
  }

  .subtitle {
    font-family: 'Rajdhani', sans-serif;
    font-size: 16px;
    color: rgba(255, 255, 255, 0.5);
    letter-spacing: 6px;
    text-transform: uppercase;
    margin-bottom: 40px;
  }

  .start-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    padding: 15px 50px;
    background: transparent;
    border: 2px solid #00ffc8;
    color: #00ffc8;
    cursor: pointer;
    letter-spacing: 4px;
    text-transform: uppercase;
    transition: all 0.3s;
    border-radius: 2px;
    margin-bottom: 15px;
  }

  .start-btn:hover {
    background: rgba(0, 255, 200, 0.15);
    box-shadow: 0 0 30px rgba(0, 255, 200, 0.3);
  }

  .scores-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    padding: 10px 30px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.5);
    cursor: pointer;
    letter-spacing: 3px;
    text-transform: uppercase;
    transition: all 0.3s;
    border-radius: 2px;
    margin-bottom: 20px;
  }

  .scores-btn:hover {
    border-color: rgba(0, 255, 200, 0.4);
    color: #00ffc8;
  }

  .controls-info {
    font-family: 'Rajdhani', sans-serif;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.35);
    letter-spacing: 2px;
  }

  .sound-toggle {
    position: absolute;
    top: 10px;
    right: 10px;
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    padding: 6px 12px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
    letter-spacing: 2px;
    z-index: 25;
    border-radius: 2px;
    pointer-events: auto;
  }

  .sound-toggle:hover { border-color: #00ffc8; color: #00ffc8; }

  #bossBar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 400px;
    text-align: center;
    pointer-events: none;
    z-index: 10;
    display: none;
  }

  .boss-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    color: #ff3366;
    letter-spacing: 3px;
    margin-bottom: 6px;
  }

  .boss-health-bar {
    width: 100%;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid rgba(255, 51, 102, 0.4);
  }

  .boss-health-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff3366, #ff6699);
    border-radius: 3px;
    transition: width 0.2s;
    box-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
  }

  /* High Scores Table */
  .scores-panel {
    width: 400px;
    margin-top: 10px;
    margin-bottom: 20px;
  }

  .scores-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    color: #00ffc8;
    letter-spacing: 4px;
    text-align: center;
    margin-bottom: 15px;
    text-shadow: 0 0 10px rgba(0,255,200,0.3);
  }

  .score-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    font-family: 'Rajdhani', sans-serif;
    font-size: 15px;
    letter-spacing: 1px;
  }

  .score-row .rank {
    color: rgba(0,255,200,0.5);
    width: 30px;
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
  }

  .score-row .score-name {
    color: rgba(255,255,255,0.7);
    flex: 1;
    text-align: left;
    padding-left: 10px;
  }

  .score-row .score-val {
    color: #00ffc8;
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
  }

  .score-row .score-level {
    color: rgba(255,255,255,0.35);
    width: 50px;
    text-align: right;
    font-size: 12px;
  }

  .score-row.highlight {
    background: rgba(0, 255, 200, 0.05);
    border: 1px solid rgba(0, 255, 200, 0.15);
    border-radius: 3px;
  }

  .score-row.empty .score-name { color: rgba(255,255,255,0.15); }
  .score-row.empty .score-val { color: rgba(0,255,200,0.15); }

  .name-input-wrap {
    text-align: center;
    margin: 15px 0;
  }

  .name-input-wrap input {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    background: transparent;
    border: 1px solid rgba(0,255,200,0.4);
    color: #00ffc8;
    padding: 8px 16px;
    width: 200px;
    text-align: center;
    letter-spacing: 3px;
    text-transform: uppercase;
    outline: none;
    border-radius: 2px;
  }

  .name-input-wrap input::placeholder {
    color: rgba(0,255,200,0.25);
  }

  .name-input-wrap button {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    padding: 8px 20px;
    margin-left: 8px;
    background: rgba(0,255,200,0.1);
    border: 1px solid #00ffc8;
    color: #00ffc8;
    cursor: pointer;
    letter-spacing: 2px;
    border-radius: 2px;
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="hud">
    <div class="hud-section">
      <div>
        <div class="hud-label">Shield</div>
        <div class="health-bar"><div class="health-fill" id="healthFill"></div></div>
      </div>
      <div>
        <div class="hud-label">Lives</div>
        <div id="livesDisplay"></div>
      </div>
    </div>
    <div class="hud-section">
      <div style="text-align:center">
        <div class="hud-label">Level</div>
        <div class="hud-value" id="levelDisplay">1</div>
      </div>
      <div style="text-align:center">
        <div class="hud-label">Score</div>
        <div class="hud-value" id="scoreDisplay">0</div>
      </div>
    </div>
    <div class="hud-section">
      <div style="text-align:right">
        <div class="hud-label">Power</div>
        <div class="hud-value" id="powerDisplay">1</div>
      </div>
      <button class="sound-toggle" id="soundToggle">SFX ON</button>
    </div>
  </div>

  <div id="bossBar">
    <div class="boss-name" id="bossName">BOSS</div>
    <div class="boss-health-bar"><div class="boss-health-fill" id="bossHealthFill"></div></div>
  </div>

  <div id="overlay">
    <div class="title">NOVA STRIKE</div>
    <div class="subtitle">Deep Space Combat</div>
    <button class="start-btn" id="startBtn">Launch Mission</button>
    <button class="scores-btn" id="scoresBtn">High Scores</button>
    <div class="controls-info">ARROWS ‚Äî Move &nbsp;&nbsp; SPACE ‚Äî Fire</div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = 800, H = 600;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üîä RETRO 80s SOUND ENGINE (Web Audio)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let audioCtx = null;
let soundEnabled = true;

function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, duration, type = 'square', volume = 0.15, slide = 0) {
  if (!soundEnabled || !audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  osc.type = type;
  osc.frequency.setValueAtTime(freq, now);
  if (slide) osc.frequency.linearRampToValueAtTime(freq + slide, now + duration);
  gain.gain.setValueAtTime(volume, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + duration);
}

function playNoise(duration, volume = 0.1) {
  if (!soundEnabled || !audioCtx) return;
  const bufferSize = audioCtx.sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  const source = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  source.buffer = buffer;
  gain.gain.setValueAtTime(volume, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
  source.connect(gain);
  gain.connect(audioCtx.destination);
  source.start(now);
}

const SFX = {
  shoot: () => playTone(880, 0.06, 'square', 0.08, 200),
  shootPower: () => { playTone(660, 0.08, 'square', 0.07, 400); playTone(990, 0.06, 'sawtooth', 0.05, 200); },
  hit: () => { playTone(200, 0.1, 'square', 0.12, -100); playNoise(0.05, 0.08); },
  enemyDie: () => { playTone(400, 0.15, 'square', 0.12, -300); playNoise(0.1, 0.1); },
  bossHit: () => { playTone(150, 0.12, 'sawtooth', 0.1, -50); playNoise(0.06, 0.06); },
  bossDie: () => {
    const now = audioCtx.currentTime;
    [200, 300, 400, 500, 700, 900].forEach((f, i) => {
      setTimeout(() => { playTone(f, 0.2, 'square', 0.12, -100); playNoise(0.15, 0.08); }, i * 80);
    });
  },
  powerup: () => {
    [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.1, 'square', 0.1), i * 50));
  },
  playerHit: () => { playTone(100, 0.2, 'sawtooth', 0.15, -50); playNoise(0.15, 0.12); },
  playerDie: () => {
    [400, 350, 300, 200, 150, 100].forEach((f, i) => setTimeout(() => {
      playTone(f, 0.2, 'square', 0.12, -50); playNoise(0.12, 0.1);
    }, i * 100));
  },
  levelUp: () => {
    [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'square', 0.1, 50), i * 80));
  },
  bossWarn: () => {
    [200, 300, 200, 300, 200, 400].forEach((f, i) => setTimeout(() => playTone(f, 0.12, 'sawtooth', 0.1), i * 120));
  },
  menuSelect: () => playTone(1200, 0.08, 'square', 0.08, -400),
  shieldBreak: () => { playTone(600, 0.15, 'sawtooth', 0.1, -400); playNoise(0.1, 0.08); },
  victory: () => {
    const melody = [523, 659, 784, 1047, 784, 1047, 1319];
    melody.forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'square', 0.12, 20), i * 120));
  },
  evolve: () => {
    [400, 600, 800, 1000, 1200, 1400].forEach((f, i) => setTimeout(() => playTone(f, 0.08, 'square', 0.08, 100), i * 40));
    setTimeout(() => playTone(1600, 0.2, 'sine', 0.06, -200), 250);
  },
  bgPulse: () => playTone(55, 0.4, 'sine', 0.03),
};

// Sound toggle
document.getElementById('soundToggle').addEventListener('click', () => {
  soundEnabled = !soundEnabled;
  document.getElementById('soundToggle').textContent = soundEnabled ? 'SFX ON' : 'SFX OFF';
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèÜ HIGH SCORES SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MAX_SCORES = 10;

function getHighScores() {
  try {
    const data = localStorage.getItem('novaStrikeScores');
    return data ? JSON.parse(data) : [];
  } catch(e) { return []; }
}

function saveHighScore(name, score, level) {
  const scores = getHighScores();
  scores.push({ name: name.toUpperCase().substring(0, 8), score, level, date: Date.now() });
  scores.sort((a, b) => b.score - a.score);
  if (scores.length > MAX_SCORES) scores.length = MAX_SCORES;
  try { localStorage.setItem('novaStrikeScores', JSON.stringify(scores)); } catch(e) {}
  return scores;
}

function isHighScore(score) {
  const scores = getHighScores();
  return scores.length < MAX_SCORES || score > (scores[scores.length - 1]?.score || 0);
}

function buildScoresHTML(highlightScore = -1) {
  const scores = getHighScores();
  let html = '<div class="scores-panel"><div class="scores-title">TOP PILOTS</div>';
  for (let i = 0; i < MAX_SCORES; i++) {
    const s = scores[i];
    const hl = s && s.score === highlightScore ? ' highlight' : '';
    if (s) {
      html += `<div class="score-row${hl}">
        <span class="rank">${i + 1}.</span>
        <span class="score-name">${s.name}</span>
        <span class="score-val">${s.score.toLocaleString()}</span>
        <span class="score-level">LV${s.level}</span>
      </div>`;
    } else {
      html += `<div class="score-row empty">
        <span class="rank">${i + 1}.</span>
        <span class="score-name">---</span>
        <span class="score-val">0</span>
        <span class="score-level">--</span>
      </div>`;
    }
  }
  html += '</div>';
  return html;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üéÆ GAME STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let game = {
  running: false, score: 0, level: 1, lives: 3,
  phase: 'title', transitionTimer: 0,
  enemiesKilled: 0, enemiesNeeded: 0,
  shakeTimer: 0, shakeIntensity: 0,
  bgPulseTimer: 0, loopStarted: false
};

const LEVEL_DATA = [
  { name: "ASTEROID BELT", enemies: 15, bg: '#0a0a1a', starColor: '#334', enemySpeed: 1, enemyHP: 1, bossName: "SENTINEL DRONE", bossHP: 30, bossColor: '#ff4466' },
  { name: "NEBULA RIFT", enemies: 20, bg: '#0a0f1a', starColor: '#234', enemySpeed: 1.3, enemyHP: 2, bossName: "NEBULA WYRM", bossHP: 50, bossColor: '#aa44ff' },
  { name: "DARK SECTOR", enemies: 25, bg: '#0f0a0a', starColor: '#322', enemySpeed: 1.6, enemyHP: 2, bossName: "SHADOW CRUISER", bossHP: 70, bossColor: '#ff8800' },
  { name: "ION STORM", enemies: 30, bg: '#0a0a0f', starColor: '#223', enemySpeed: 1.9, enemyHP: 3, bossName: "STORM TITAN", bossHP: 100, bossColor: '#44ddff' },
  { name: "CORE BREACH", enemies: 35, bg: '#0f0505', starColor: '#311', enemySpeed: 2.2, enemyHP: 3, bossName: "NOVA OVERLORD", bossHP: 140, bossColor: '#ff2222' }
];

let player = {
  x: 400, y: 500, w: 40, h: 40,
  speed: 5, hp: 100, maxHp: 100,
  power: 1, fireRate: 12, fireCooldown: 0,
  invincible: 0, shieldActive: false, upgradeFlash: 0
};

let bullets = [], enemies = [], particles = [], powerups = [], enemyBullets = [], stars = [];
let boss = null;
let keys = {};

// ‚îÄ‚îÄ Stars ‚îÄ‚îÄ
function initStars() {
  stars = [];
  for (let i = 0; i < 120; i++) {
    stars.push({ x: Math.random() * W, y: Math.random() * H, speed: 0.3 + Math.random() * 1.5, size: 0.5 + Math.random() * 1.5, brightness: 0.3 + Math.random() * 0.7 });
  }
}
initStars();

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ
document.addEventListener('keydown', e => { keys[e.code] = true; if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
document.addEventListener('keyup', e => { keys[e.code] = false; });

document.getElementById('startBtn').addEventListener('click', () => { initAudio(); SFX.menuSelect(); startGame(); });
document.getElementById('scoresBtn').addEventListener('click', () => { initAudio(); SFX.menuSelect(); showScoresScreen(); });

function startGame() {
  game = { running: true, score: 0, level: 1, lives: 3, phase: 'levelTransition', transitionTimer: 120, enemiesKilled: 0, enemiesNeeded: LEVEL_DATA[0].enemies, shakeTimer: 0, shakeIntensity: 0, bgPulseTimer: 0, loopStarted: game.loopStarted };
  player = { x: 400, y: 500, w: 40, h: 40, speed: 5, hp: 100, maxHp: 100, power: 1, fireRate: 12, fireCooldown: 0, invincible: 60, shieldActive: false, upgradeFlash: 0 };
  bullets = []; enemies = []; particles = []; powerups = []; enemyBullets = []; boss = null;
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('bossBar').style.display = 'none';
  SFX.levelUp();
  updateHUD();
  if (!game.loopStarted) { game.loopStarted = true; gameLoop(); }
}

function showScoresScreen() {
  const overlay = document.getElementById('overlay');
  overlay.innerHTML = `
    <div class="title" style="font-size:28px;">HIGH SCORES</div>
    ${buildScoresHTML()}
    <button class="start-btn" onclick="showTitleScreen()">BACK</button>
  `;
}

function showTitleScreen() {
  SFX.menuSelect();
  const overlay = document.getElementById('overlay');
  overlay.classList.remove('hidden');
  overlay.innerHTML = `
    <div class="title">NOVA STRIKE</div>
    <div class="subtitle">Deep Space Combat</div>
    <button class="start-btn" onclick="initAudio(); SFX.menuSelect(); startGame();">Launch Mission</button>
    <button class="scores-btn" onclick="initAudio(); SFX.menuSelect(); showScoresScreen();">High Scores</button>
    <div class="controls-info">ARROWS ‚Äî Move &nbsp;&nbsp; SPACE ‚Äî Fire</div>
  `;
}

// ‚îÄ‚îÄ Lives System ‚îÄ‚îÄ
function updateLivesDisplay() {
  const el = document.getElementById('livesDisplay');
  let html = '';
  for (let i = 0; i < 3; i++) {
    html += `<div class="life-icon${i >= game.lives ? ' lost' : ''}"></div>`;
  }
  el.innerHTML = html;
}

function playerDeath() {
  game.lives--;
  SFX.playerDie();
  spawnParticles(player.x, player.y, '#00ffc8', 40, 20, 5);
  spawnParticles(player.x, player.y, '#fff', 20, 15, 4);
  screenShake(10, 20);

  if (game.lives <= 0) {
    game.phase = 'gameOver';
    setTimeout(() => showEndScreen(false), 800);
  } else {
    // Respawn
    game.phase = 'respawning';
    game.transitionTimer = 90;
    setTimeout(() => {
      player.x = 400; player.y = 500;
      player.hp = player.maxHp;
      player.invincible = 120;
      player.shieldActive = false;
      player.upgradeFlash = 0;
      enemyBullets = [];
      if (game.phase === 'respawning') {
        game.phase = boss ? 'bossPhase' : 'playing';
      }
    }, 1500);
  }
  updateLivesDisplay();
}

// ‚îÄ‚îÄ Spawn Functions ‚îÄ‚îÄ
function spawnEnemy() {
  const ld = LEVEL_DATA[game.level - 1];
  const type = Math.random() < 0.3 ? 'zigzag' : Math.random() < 0.5 ? 'charger' : 'basic';
  enemies.push({
    x: 40 + Math.random() * (W - 80), y: -40,
    w: 30 + Math.random() * 15, h: 30 + Math.random() * 15,
    hp: ld.enemyHP, speed: ld.enemySpeed * (0.8 + Math.random() * 0.4),
    type, timer: 0, shootTimer: 60 + Math.random() * 120,
    color: type === 'zigzag' ? '#ff66aa' : type === 'charger' ? '#ffaa44' : '#66aaff'
  });
}

function spawnBoss() {
  const ld = LEVEL_DATA[game.level - 1];
  boss = {
    x: W / 2, y: -80, targetY: 100,
    w: 80 + game.level * 10, h: 60 + game.level * 8,
    hp: ld.bossHP, maxHp: ld.bossHP,
    speed: 1.5, dir: 1, phase: 0, timer: 0, shootPattern: 0,
    name: ld.bossName, color: ld.bossColor, entering: true
  };
  document.getElementById('bossBar').style.display = 'block';
  document.getElementById('bossName').textContent = ld.bossName;
  document.getElementById('bossHealthFill').style.width = '100%';
  game.phase = 'bossPhase';
  SFX.bossWarn();
}

function spawnPowerup(x, y) {
  if (Math.random() > 0.25) return;
  const types = ['power', 'speed', 'health', 'shield', 'rapid'];
  const weights = [0.3, 0.15, 0.25, 0.1, 0.2];
  let r = Math.random(), acc = 0, type = types[0];
  for (let i = 0; i < types.length; i++) { acc += weights[i]; if (r < acc) { type = types[i]; break; } }
  const colors = { power: '#ff4488', speed: '#44ff88', health: '#44ddff', shield: '#ffdd44', rapid: '#ff8844' };
  const labels = { power: 'P', speed: 'S', health: 'H', shield: '‚óÜ', rapid: 'R' };
  powerups.push({ x, y, type, color: colors[type], label: labels[type], size: 16, timer: 0 });
}

function spawnParticles(x, y, color, count, spread, speed) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const vel = (0.5 + Math.random() * speed);
    particles.push({
      x: x + (Math.random() - 0.5) * spread, y: y + (Math.random() - 0.5) * spread,
      vx: Math.cos(angle) * vel, vy: Math.sin(angle) * vel,
      life: 30 + Math.random() * 30, maxLife: 30 + Math.random() * 30,
      color, size: 1 + Math.random() * 3
    });
  }
}

function rectCollide(a, b) {
  return a.x - a.w/2 < b.x + b.w/2 && a.x + a.w/2 > b.x - b.w/2 &&
         a.y - a.h/2 < b.y + b.h/2 && a.y + a.h/2 > b.y - b.h/2;
}

function screenShake(intensity, duration) {
  game.shakeIntensity = intensity;
  game.shakeTimer = duration;
}

// ‚îÄ‚îÄ Shoot ‚îÄ‚îÄ
function playerShoot() {
  if (player.fireCooldown > 0) return;
  player.fireCooldown = player.fireRate;
  const bw = 3, bh = 12, spd = 8, dmg = player.power;

  if (player.power >= 5) {
    SFX.shootPower();
    bullets.push({ x: player.x, y: player.y - 25, w: bw+2, h: bh+4, vy: -spd-2, vx: 0, dmg, color: '#ff44ff' });
    bullets.push({ x: player.x - 15, y: player.y - 20, w: bw, h: bh, vy: -spd, vx: -0.5, dmg, color: '#ff44ff' });
    bullets.push({ x: player.x + 15, y: player.y - 20, w: bw, h: bh, vy: -spd, vx: 0.5, dmg, color: '#ff44ff' });
    bullets.push({ x: player.x - 28, y: player.y - 15, w: bw, h: bh, vy: -spd+1, vx: -1, dmg: dmg-1, color: '#cc44ff' });
    bullets.push({ x: player.x + 28, y: player.y - 15, w: bw, h: bh, vy: -spd+1, vx: 1, dmg: dmg-1, color: '#cc44ff' });
  } else if (player.power >= 3) {
    SFX.shootPower();
    bullets.push({ x: player.x, y: player.y - 25, w: bw+1, h: bh+2, vy: -spd-1, vx: 0, dmg, color: '#44ffdd' });
    bullets.push({ x: player.x - 12, y: player.y - 20, w: bw, h: bh, vy: -spd, vx: -0.3, dmg, color: '#44ffdd' });
    bullets.push({ x: player.x + 12, y: player.y - 20, w: bw, h: bh, vy: -spd, vx: 0.3, dmg, color: '#44ffdd' });
  } else if (player.power >= 2) {
    SFX.shoot();
    bullets.push({ x: player.x - 8, y: player.y - 22, w: bw, h: bh, vy: -spd, vx: 0, dmg, color: '#00ffc8' });
    bullets.push({ x: player.x + 8, y: player.y - 22, w: bw, h: bh, vy: -spd, vx: 0, dmg, color: '#00ffc8' });
  } else {
    SFX.shoot();
    bullets.push({ x: player.x, y: player.y - 22, w: bw, h: bh, vy: -spd, vx: 0, dmg, color: '#00ffc8' });
  }
}

// ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ
function update() {
  if (!game.running) return;

  // Stars always move
  stars.forEach(s => { s.y += s.speed; if (s.y > H) { s.y = 0; s.x = Math.random() * W; } });

  // BG pulse
  game.bgPulseTimer++;
  if (game.bgPulseTimer % 120 === 0 && game.phase !== 'title') SFX.bgPulse();

  if (game.phase === 'levelTransition') {
    game.transitionTimer--;
    if (game.transitionTimer <= 0) {
      game.phase = 'playing';
      game.enemiesKilled = 0;
      game.enemiesNeeded = LEVEL_DATA[game.level - 1].enemies;
    }
    return;
  }

  if (game.phase === 'gameOver' || game.phase === 'victory') return;

  // Player visible?
  const playerAlive = game.phase !== 'respawning';

  // Player movement
  if (playerAlive) {
    if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
    if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
    if (keys['ArrowUp'] || keys['KeyW']) player.y -= player.speed;
    if (keys['ArrowDown'] || keys['KeyS']) player.y += player.speed;
    player.x = Math.max(player.w/2, Math.min(W - player.w/2, player.x));
    player.y = Math.max(player.h/2, Math.min(H - player.h/2, player.y));
    if (keys['Space']) playerShoot();
  }

  if (player.fireCooldown > 0) player.fireCooldown--;
  if (player.invincible > 0) player.invincible--;

  // Spawn enemies
  if (game.phase === 'playing' && game.enemiesKilled < game.enemiesNeeded) {
    if (Math.random() < 0.02 + game.level * 0.005) spawnEnemy();
  }
  if (game.phase === 'playing' && game.enemiesKilled >= game.enemiesNeeded && enemies.length === 0) {
    spawnBoss();
  }

  // Update bullets
  bullets = bullets.filter(b => { b.x += b.vx || 0; b.y += b.vy; return b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20; });
  enemyBullets = enemyBullets.filter(b => { b.x += b.vx; b.y += b.vy; return b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20; });

  // Update enemies
  enemies.forEach(e => {
    e.timer++;
    if (e.type === 'zigzag') { e.x += Math.sin(e.timer * 0.05) * 2; e.y += e.speed; }
    else if (e.type === 'charger') { if (e.timer > 60) e.speed += 0.02; e.y += e.speed; e.x += Math.sign(player.x - e.x) * 0.5; }
    else { e.y += e.speed; }
    e.shootTimer--;
    if (e.shootTimer <= 0 && e.y > 20 && e.y < H - 100) {
      e.shootTimer = 80 + Math.random() * 60;
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      enemyBullets.push({ x: e.x, y: e.y + e.h/2, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, w: 5, h: 5, color: '#ff3366' });
    }
  });
  enemies = enemies.filter(e => e.y < H + 50);

  // Update boss
  if (boss) {
    if (boss.entering) {
      boss.y += 1.5;
      if (boss.y >= boss.targetY) boss.entering = false;
    } else {
      boss.timer++;
      boss.x += boss.speed * boss.dir;
      if (boss.x < boss.w/2 + 30 || boss.x > W - boss.w/2 - 30) boss.dir *= -1;
      if (boss.timer % 30 === 0) {
        const pattern = boss.timer % 180 < 90 ? 'spread' : 'aimed';
        if (pattern === 'spread') {
          for (let i = -2; i <= 2; i++) {
            const angle = Math.PI/2 + i * 0.25;
            enemyBullets.push({ x: boss.x, y: boss.y + boss.h/2, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, w: 6, h: 6, color: boss.color });
          }
        } else {
          const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
          enemyBullets.push({ x: boss.x, y: boss.y + boss.h/2, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, w: 8, h: 8, color: boss.color });
        }
      }
      if (game.level >= 3 && boss.timer % 90 === 45) {
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 / 8) * i + boss.timer * 0.01;
          enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5, w: 5, h: 5, color: '#ffaa00' });
        }
      }
    }
  }

  // Bullet-enemy collisions
  bullets.forEach(b => {
    enemies.forEach(e => {
      if (rectCollide({x:b.x,y:b.y,w:b.w,h:b.h}, e)) {
        e.hp -= b.dmg; b.vy = 0; b.y = -100;
        spawnParticles(b.x, b.y, e.color, 5, 5, 2);
        SFX.hit();
        if (e.hp <= 0) {
          game.score += 100 * game.level;
          game.enemiesKilled++;
          spawnParticles(e.x, e.y, e.color, 20, 15, 4);
          spawnPowerup(e.x, e.y);
          SFX.enemyDie();
          e.y = H + 100;
          screenShake(3, 5);
        }
      }
    });
    if (boss && !boss.entering && rectCollide({x:b.x,y:b.y,w:b.w,h:b.h}, boss)) {
      boss.hp -= b.dmg; b.vy = 0; b.y = -100;
      spawnParticles(b.x, b.y, boss.color, 3, 5, 2);
      SFX.bossHit();
      if (boss.hp <= 0) {
        game.score += 1000 * game.level;
        spawnParticles(boss.x, boss.y, boss.color, 60, 40, 6);
        spawnParticles(boss.x, boss.y, '#fff', 30, 30, 5);
        screenShake(10, 20);
        SFX.bossDie();
        for (let i = 0; i < 3; i++) {
          powerups.push({ x: boss.x + (Math.random()-0.5)*60, y: boss.y + (Math.random()-0.5)*40, type: 'power', color: '#ff4488', label: 'P', size: 16, timer: 0 });
        }
        document.getElementById('bossBar').style.display = 'none';
        boss = null;
        if (game.level < 5) {
          game.level++;
          game.phase = 'levelTransition';
          game.transitionTimer = 150;
          enemyBullets = [];
          SFX.levelUp();
        } else {
          game.phase = 'victory';
          SFX.victory();
          setTimeout(() => showEndScreen(true), 1200);
        }
      } else {
        document.getElementById('bossHealthFill').style.width = (boss.hp / boss.maxHp * 100) + '%';
      }
    }
  });

  // Enemy bullet - player collision
  if (player.invincible <= 0 && playerAlive) {
    enemyBullets.forEach(b => {
      if (rectCollide({x:b.x,y:b.y,w:b.w,h:b.h}, player)) {
        if (player.shieldActive) {
          player.shieldActive = false;
          spawnParticles(player.x, player.y, '#ffdd44', 15, 20, 3);
          SFX.shieldBreak();
        } else {
          player.hp -= 10;
          screenShake(5, 8);
          SFX.playerHit();
        }
        b.y = H + 100;
        player.invincible = 30;
        if (player.hp <= 0) playerDeath();
      }
    });
    enemies.forEach(e => {
      if (rectCollide(e, player)) {
        if (player.shieldActive) {
          player.shieldActive = false;
          e.hp = 0; e.y = H + 100;
          spawnParticles(e.x, e.y, e.color, 15, 10, 4);
          SFX.shieldBreak();
        } else {
          player.hp -= 20;
          screenShake(6, 10);
          SFX.playerHit();
        }
        player.invincible = 45;
        if (player.hp <= 0) playerDeath();
      }
    });
  }

  // Powerup collection
  if (playerAlive) {
    powerups.forEach(p => {
      p.y += 1.2; p.timer++;
      if (rectCollide({x:p.x,y:p.y,w:p.size*2,h:p.size*2}, player)) {
        const prevPower = player.power;
        const prevSpeed = player.speed;
        const prevRate = player.fireRate;
        switch(p.type) {
          case 'power': player.power = Math.min(player.power + 1, 6); break;
          case 'speed': player.speed = Math.min(player.speed + 0.5, 8); break;
          case 'health': player.hp = Math.min(player.hp + 30, player.maxHp); break;
          case 'shield': player.shieldActive = true; break;
          case 'rapid': player.fireRate = Math.max(player.fireRate - 2, 4); break;
        }
        // Trigger evolution flash when ship stats change
        if (player.power > prevPower || player.speed > prevSpeed || player.fireRate < prevRate) {
          player.upgradeFlash = 20;
          SFX.evolve();
          spawnParticles(player.x, player.y, p.color, 25, 25, 4);
        } else {
          SFX.powerup();
        }
        spawnParticles(p.x, p.y, p.color, 12, 10, 3);
        p.y = H + 100;
        game.score += 50;
      }
    });
  }
  powerups = powerups.filter(p => p.y < H + 50);

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; p.vx *= 0.97; p.vy *= 0.97; });
  particles = particles.filter(p => p.life > 0);

  if (game.shakeTimer > 0) game.shakeTimer--;
  updateHUD();
}

// ‚îÄ‚îÄ DRAW ‚îÄ‚îÄ
function draw() {
  const ld = LEVEL_DATA[game.level - 1];
  ctx.fillStyle = ld.bg;
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  if (game.shakeTimer > 0) {
    ctx.translate((Math.random()-0.5) * game.shakeIntensity, (Math.random()-0.5) * game.shakeIntensity);
  }

  // Stars
  stars.forEach(s => {
    ctx.globalAlpha = s.brightness;
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;

  // Level transition
  if (game.phase === 'levelTransition') {
    const alpha = game.transitionTimer > 100 ? (150 - game.transitionTimer) / 50 : game.transitionTimer < 50 ? game.transitionTimer / 50 : 1;
    ctx.globalAlpha = alpha;
    ctx.textAlign = 'center';
    ctx.font = '900 36px Orbitron';
    ctx.fillStyle = '#00ffc8';
    ctx.shadowColor = 'rgba(0, 255, 200, 0.5)';
    ctx.shadowBlur = 20;
    ctx.fillText(`LEVEL ${game.level}`, W/2, H/2 - 20);
    ctx.font = '500 18px Rajdhani';
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.shadowBlur = 0;
    ctx.fillText(ld.name, W/2, H/2 + 20);
    ctx.globalAlpha = 1;
    ctx.restore();
    return;
  }

  // Powerups
  powerups.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    const pulse = 1 + Math.sin(p.timer * 0.1) * 0.15;
    ctx.scale(pulse, pulse);
    ctx.shadowColor = p.color; ctx.shadowBlur = 15;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(0, 0, p.size, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath(); ctx.arc(0, 0, p.size - 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(p.label, 0, 1);
    ctx.restore();
  });

  // Enemy bullets
  enemyBullets.forEach(b => {
    ctx.shadowColor = b.color; ctx.shadowBlur = 8;
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.w/2, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
  });

  // Player bullets (evolve with power)
  bullets.forEach(b => {
    ctx.save();
    ctx.shadowColor = b.color; ctx.shadowBlur = player.power >= 3 ? 15 : 10;
    ctx.fillStyle = b.color;
    if (player.power >= 5) {
      // Plasma bolts
      ctx.beginPath(); ctx.ellipse(b.x, b.y, b.w/2 + 1, b.h/2 + 2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, b.w/4, b.h/3, 0, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
    } else if (player.power >= 3) {
      // Energy beams
      ctx.fillRect(b.x - b.w/2 - 0.5, b.y - b.h/2, b.w + 1, b.h + 2);
      ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.4;
      ctx.fillRect(b.x - 0.5, b.y - b.h/2, 1, b.h);
      ctx.globalAlpha = 1;
    } else {
      ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
    }
    ctx.shadowBlur = 0;
    // Trail (longer at higher power)
    const trailLen = player.power >= 4 ? 3.5 : player.power >= 2 ? 2.5 : 2;
    ctx.fillStyle = b.color + '33';
    ctx.fillRect(b.x - b.w/2, b.y, b.w, b.h * trailLen);
    ctx.restore();
  });

  // Enemies
  enemies.forEach(e => {
    ctx.save(); ctx.translate(e.x, e.y);
    ctx.fillStyle = e.color; ctx.shadowColor = e.color; ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(0, -e.h/2); ctx.lineTo(e.w/2, e.h/4); ctx.lineTo(e.w/3, e.h/2); ctx.lineTo(-e.w/3, e.h/2); ctx.lineTo(-e.w/2, e.h/4);
    ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.arc(0, 0, e.w/5, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  });

  // Boss
  if (boss) {
    ctx.save(); ctx.translate(boss.x, boss.y);
    ctx.fillStyle = boss.color; ctx.shadowColor = boss.color; ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(0, -boss.h/2); ctx.lineTo(boss.w/2, 0); ctx.lineTo(boss.w/3, boss.h/2); ctx.lineTo(-boss.w/3, boss.h/2); ctx.lineTo(-boss.w/2, 0);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = boss.color + 'aa';
    ctx.beginPath(); ctx.moveTo(-boss.w/2, 0); ctx.lineTo(-boss.w/2 - 20, boss.h/3); ctx.lineTo(-boss.w/3, boss.h/4); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(boss.w/2, 0); ctx.lineTo(boss.w/2 + 20, boss.h/3); ctx.lineTo(boss.w/3, boss.h/4); ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0;
    const coreGlow = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
    ctx.fillStyle = `rgba(255,255,255,${coreGlow})`;
    ctx.beginPath(); ctx.arc(0, 0, boss.w/6, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  // Player (evolves with power level)
  if (game.phase !== 'gameOver' && game.phase !== 'respawning') {
    ctx.save(); ctx.translate(player.x, player.y);
    if (player.invincible > 0 && Math.floor(player.invincible / 3) % 2 === 0) ctx.globalAlpha = 0.4;

    const pw = player.power;
    const t = Date.now() * 0.003;

    // Ship color evolves
    const shipColors = ['#00ffc8', '#00ffc8', '#44ffdd', '#44ddff', '#88aaff', '#cc66ff', '#ff44ff'];
    const shipColor = shipColors[Math.min(pw, 6)];
    const glowColor = shipColor;

    // Ship size grows slightly
    const scale = 1 + Math.min(pw, 6) * 0.04;
    ctx.scale(scale, scale);

    // ‚îÄ‚îÄ Engine Flames (more engines at higher power) ‚îÄ‚îÄ
    const flicker = Math.random();
    const engineColor = pw >= 5 ? 'rgba(200, 100, 255, 0.5)' : pw >= 3 ? 'rgba(100, 200, 255, 0.4)' : 'rgba(0, 200, 255, 0.3)';
    // Center engine
    ctx.fillStyle = engineColor;
    ctx.beginPath();
    ctx.moveTo(-6, player.h/2 - 2);
    ctx.lineTo(6, player.h/2 - 2);
    ctx.lineTo(0, player.h/2 + 14 + flicker * 10 + pw * 2);
    ctx.closePath(); ctx.fill();
    // Side engines at power 3+
    if (pw >= 3) {
      ctx.fillStyle = engineColor;
      ctx.beginPath();
      ctx.moveTo(-player.w/2 + 2, player.h/3 + 2);
      ctx.lineTo(-player.w/2 + 10, player.h/3 + 2);
      ctx.lineTo(-player.w/2 + 6, player.h/3 + 10 + flicker * 6 + pw);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(player.w/2 - 10, player.h/3 + 2);
      ctx.lineTo(player.w/2 - 2, player.h/3 + 2);
      ctx.lineTo(player.w/2 - 6, player.h/3 + 10 + flicker * 6 + pw);
      ctx.closePath(); ctx.fill();
    }
    // Extra rear thrusters at power 5+
    if (pw >= 5) {
      ctx.fillStyle = 'rgba(255, 100, 200, 0.4)';
      ctx.beginPath();
      ctx.moveTo(-14, player.h/2);
      ctx.lineTo(-8, player.h/2);
      ctx.lineTo(-11, player.h/2 + 8 + flicker * 5);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(8, player.h/2);
      ctx.lineTo(14, player.h/2);
      ctx.lineTo(11, player.h/2 + 8 + flicker * 5);
      ctx.closePath(); ctx.fill();
    }

    // ‚îÄ‚îÄ Wings (grow with power) ‚îÄ‚îÄ
    if (pw >= 2) {
      const wingExt = 4 + pw * 3;
      const wingColor = shipColor + 'bb';
      ctx.fillStyle = wingColor;
      ctx.shadowColor = glowColor; ctx.shadowBlur = 8;
      // Left wing
      ctx.beginPath();
      ctx.moveTo(-player.w/2, player.h/3);
      ctx.lineTo(-player.w/2 - wingExt, player.h/3 + 8);
      ctx.lineTo(-player.w/2 - wingExt + 4, player.h/6);
      ctx.lineTo(-player.w/2 + 2, player.h/6 - 4);
      ctx.closePath(); ctx.fill();
      // Right wing
      ctx.beginPath();
      ctx.moveTo(player.w/2, player.h/3);
      ctx.lineTo(player.w/2 + wingExt, player.h/3 + 8);
      ctx.lineTo(player.w/2 + wingExt - 4, player.h/6);
      ctx.lineTo(player.w/2 - 2, player.h/6 - 4);
      ctx.closePath(); ctx.fill();
      ctx.shadowBlur = 0;
    }

    // ‚îÄ‚îÄ Cannons on wings (power 4+) ‚îÄ‚îÄ
    if (pw >= 4) {
      const cannonX = player.w/2 + 4 + pw * 2;
      ctx.fillStyle = '#aaa';
      ctx.fillRect(-cannonX - 2, player.h/6 - 8, 4, 14);
      ctx.fillRect(cannonX - 2, player.h/6 - 8, 4, 14);
      // Cannon tips glow
      ctx.fillStyle = shipColor;
      ctx.shadowColor = glowColor; ctx.shadowBlur = 6;
      ctx.beginPath(); ctx.arc(-cannonX, player.h/6 - 10, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cannonX, player.h/6 - 10, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
    }

    // ‚îÄ‚îÄ Main Ship Body ‚îÄ‚îÄ
    ctx.fillStyle = shipColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = 12 + pw * 2;
    ctx.beginPath();
    if (pw >= 5) {
      // Sleek advanced hull
      ctx.moveTo(0, -player.h/2 - 6);
      ctx.lineTo(player.w/2 + 4, player.h/4);
      ctx.lineTo(player.w/3 + 2, player.h/2);
      ctx.lineTo(0, player.h/2 - 4);
      ctx.lineTo(-player.w/3 - 2, player.h/2);
      ctx.lineTo(-player.w/2 - 4, player.h/4);
    } else if (pw >= 3) {
      // Wider hull
      ctx.moveTo(0, -player.h/2 - 3);
      ctx.lineTo(player.w/2 + 2, player.h/4);
      ctx.lineTo(player.w/3, player.h/2);
      ctx.lineTo(-player.w/3, player.h/2);
      ctx.lineTo(-player.w/2 - 2, player.h/4);
    } else {
      // Base hull
      ctx.moveTo(0, -player.h/2);
      ctx.lineTo(player.w/2, player.h/3);
      ctx.lineTo(player.w/4, player.h/2);
      ctx.lineTo(-player.w/4, player.h/2);
      ctx.lineTo(-player.w/2, player.h/3);
    }
    ctx.closePath(); ctx.fill();

    // ‚îÄ‚îÄ Hull Detail Lines ‚îÄ‚îÄ
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    if (pw >= 2) {
      ctx.beginPath(); ctx.moveTo(-player.w/4, player.h/4); ctx.lineTo(0, -player.h/4); ctx.lineTo(player.w/4, player.h/4); ctx.stroke();
    }
    if (pw >= 4) {
      ctx.strokeStyle = shipColor + '44';
      ctx.beginPath(); ctx.moveTo(-player.w/3, player.h/3); ctx.lineTo(-player.w/2, player.h/6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(player.w/3, player.h/3); ctx.lineTo(player.w/2, player.h/6); ctx.stroke();
    }

    // ‚îÄ‚îÄ Cockpit (evolves) ‚îÄ‚îÄ
    if (pw >= 5) {
      // Glowing energy core
      const coreP = 0.5 + Math.sin(t * 2) * 0.3;
      ctx.fillStyle = `rgba(255, 150, 255, ${coreP})`;
      ctx.shadowColor = '#ff66ff'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.ellipse(0, -4, 6, 10, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(255, 255, 255, ${coreP * 0.6})`;
      ctx.beginPath(); ctx.ellipse(0, -4, 3, 5, 0, 0, Math.PI * 2); ctx.fill();
    } else if (pw >= 3) {
      ctx.fillStyle = 'rgba(100, 220, 255, 0.5)';
      ctx.shadowColor = '#44ddff'; ctx.shadowBlur = 6;
      ctx.beginPath(); ctx.ellipse(0, -3, 5, 9, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath(); ctx.ellipse(0, -3, 2.5, 5, 0, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath(); ctx.ellipse(0, -2, 5, 8, 0, 0, Math.PI * 2); ctx.fill();
    }
    ctx.shadowBlur = 0;

    // ‚îÄ‚îÄ Speed Trail (when speed upgraded) ‚îÄ‚îÄ
    if (player.speed > 5.5) {
      const trailAlpha = Math.min((player.speed - 5) * 0.08, 0.3);
      ctx.globalAlpha = trailAlpha;
      ctx.fillStyle = shipColor;
      for (let i = 1; i <= 3; i++) {
        ctx.fillRect(-2, player.h/2 + i * 8, 4, 4);
      }
      ctx.globalAlpha = player.invincible > 0 && Math.floor(player.invincible / 3) % 2 === 0 ? 0.4 : 1;
    }

    // ‚îÄ‚îÄ Rapid Fire Indicator (spinning ring) ‚îÄ‚îÄ
    if (player.fireRate < 10) {
      ctx.strokeStyle = 'rgba(255, 136, 68, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, 0, 22, t % (Math.PI*2), (t % (Math.PI*2)) + Math.PI * 0.5);
      ctx.stroke();
    }

    // ‚îÄ‚îÄ Shield ‚îÄ‚îÄ
    if (player.shieldActive) {
      const shieldPulse = 0.3 + Math.sin(t * 3) * 0.15;
      ctx.strokeStyle = `rgba(255, 221, 68, ${shieldPulse + 0.2})`;
      ctx.lineWidth = 2;
      ctx.shadowColor = '#ffdd44'; ctx.shadowBlur = 15;
      ctx.beginPath(); ctx.arc(0, 0, 30 + pw, 0, Math.PI * 2); ctx.stroke();
      // Hex pattern on shield
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = `rgba(255, 221, 68, ${shieldPulse * 0.5})`;
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI * 2 / 6) * i + t;
        const r = 30 + pw;
        ctx.beginPath(); ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        ctx.lineTo(Math.cos(a + Math.PI*2/6) * r, Math.sin(a + Math.PI*2/6) * r);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }

    // ‚îÄ‚îÄ Upgrade Flash Effect ‚îÄ‚îÄ
    if (player.upgradeFlash > 0) {
      ctx.globalAlpha = player.upgradeFlash / 20;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(0, 0, 35 + (20 - player.upgradeFlash) * 2, 0, Math.PI * 2); ctx.fill();
      player.upgradeFlash--;
    }

    ctx.restore();
  }

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ‚îÄ‚îÄ HUD ‚îÄ‚îÄ
function updateHUD() {
  document.getElementById('healthFill').style.width = Math.max(0, player.hp / player.maxHp * 100) + '%';
  document.getElementById('healthFill').style.background = player.hp / player.maxHp < 0.3 ?
    'linear-gradient(90deg, #ff3366, #ff6644)' : 'linear-gradient(90deg, #00ffc8, #00ff88)';
  document.getElementById('scoreDisplay').textContent = game.score.toLocaleString();
  document.getElementById('levelDisplay').textContent = game.level;
  document.getElementById('powerDisplay').textContent = player.power;
  updateLivesDisplay();
  if (boss) document.getElementById('bossHealthFill').style.width = (boss.hp / boss.maxHp * 100) + '%';
}

// ‚îÄ‚îÄ End Screen ‚îÄ‚îÄ
function showEndScreen(victory) {
  const overlay = document.getElementById('overlay');
  overlay.classList.remove('hidden');

  const canSave = isHighScore(game.score);

  if (victory) {
    let html = `
      <div class="title" style="font-size:42px;color:#ffdd44;">MISSION COMPLETE</div>
      <div class="subtitle">FINAL SCORE: ${game.score.toLocaleString()}</div>`;
    if (canSave) {
      html += `<div class="name-input-wrap">
        <input type="text" id="nameInput" placeholder="YOUR NAME" maxlength="8" autofocus>
        <button onclick="submitScore()">SAVE</button>
      </div>`;
    }
    html += `${buildScoresHTML()}
      <button class="start-btn" onclick="initAudio(); SFX.menuSelect(); startGame();">PLAY AGAIN</button>
      <div class="controls-info">ALL SECTORS CLEARED</div>`;
    overlay.innerHTML = html;
  } else {
    let html = `
      <div class="title" style="font-size:42px;color:#ff3366;">DESTROYED</div>
      <div class="subtitle">SCORE: ${game.score.toLocaleString()} ‚Äî LEVEL ${game.level}</div>`;
    if (canSave) {
      html += `<div class="name-input-wrap">
        <input type="text" id="nameInput" placeholder="YOUR NAME" maxlength="8" autofocus>
        <button onclick="submitScore()">SAVE</button>
      </div>`;
    }
    html += `${buildScoresHTML()}
      <button class="start-btn" onclick="initAudio(); SFX.menuSelect(); startGame();">RETRY MISSION</button>
      <div class="controls-info">ARROWS ‚Äî Move &nbsp;&nbsp; SPACE ‚Äî Fire</div>`;
    overlay.innerHTML = html;
  }

  // Focus name input
  const inp = document.getElementById('nameInput');
  if (inp) {
    inp.focus();
    inp.addEventListener('keydown', e => { if (e.key === 'Enter') submitScore(); });
  }
}

function submitScore() {
  const inp = document.getElementById('nameInput');
  if (!inp) return;
  const name = inp.value.trim() || 'PILOT';
  SFX.menuSelect();
  saveHighScore(name, game.score, game.level);
  // Refresh the overlay with updated scores
  const wrap = document.querySelector('.name-input-wrap');
  if (wrap) wrap.remove();
  const panel = document.querySelector('.scores-panel');
  if (panel) panel.outerHTML = buildScoresHTML(game.score);
}

// ‚îÄ‚îÄ Game Loop ‚îÄ‚îÄ
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
