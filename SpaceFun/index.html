<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceFun - Kids Space Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        canvas {
            border: 3px solid #4a90d9;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(74, 144, 217, 0.4);
        }
    </style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game constants
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const STAR_COUNT = 120;
const PLAYER_SPEED = 5;
const BULLET_SPEED = 7;
const ENEMY_BASE_SPEED = 1.5;
const POWERUP_SPEED = 1.5;
const SPAWN_INTERVAL_MS = 1200;
const POWERUP_INTERVAL_MS = 8000;

// Game state
const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
let gameState = STATE.MENU;
let score = 0;
let highScore = parseInt(localStorage.getItem('spacefun_highscore')) || 0;
let lives = 3;
let shield = false;
let shieldTimer = 0;
let rapidFire = false;
let rapidFireTimer = 0;
let lastSpawn = 0;
let lastPowerup = 0;
let lastShot = 0;
let shotCooldown = 300;
let difficultyMultiplier = 1;
let gameTime = 0;

// Input
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') e.preventDefault();
    if (gameState === STATE.MENU && e.code === 'Space') startGame();
    if (gameState === STATE.GAMEOVER && e.code === 'Space') startGame();
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Stars background
const stars = [];
for (let i = 0; i < STAR_COUNT; i++) {
    stars.push({
        x: Math.random() * GAME_WIDTH,
        y: Math.random() * GAME_HEIGHT,
        size: Math.random() * 2.5 + 0.5,
        speed: Math.random() * 1.5 + 0.3,
        twinkle: Math.random() * Math.PI * 2
    });
}

// Player
const player = {
    x: 100, y: GAME_HEIGHT / 2,
    width: 48, height: 36,
    color: '#4ae0ff',
    trail: []
};

// Entity arrays
let bullets = [];
let enemies = [];
let powerups = [];
let particles = [];
let explosions = [];

function startGame() {
    gameState = STATE.PLAYING;
    score = 0;
    lives = 3;
    shield = false;
    rapidFire = false;
    shieldTimer = 0;
    rapidFireTimer = 0;
    difficultyMultiplier = 1;
    gameTime = 0;
    shotCooldown = 300;
    player.x = 100;
    player.y = GAME_HEIGHT / 2;
    player.trail = [];
    bullets = [];
    enemies = [];
    powerups = [];
    particles = [];
    explosions = [];
    lastSpawn = performance.now();
    lastPowerup = performance.now();
    lastShot = 0;
}

// Draw the rocket ship player
function drawPlayer() {
    const px = player.x;
    const py = player.y;

    // Engine trail
    player.trail.push({ x: px - 20, y: py, alpha: 1, size: 8 + Math.random() * 4 });
    if (player.trail.length > 12) player.trail.shift();
    player.trail.forEach((t, i) => {
        const colors = ['#ff6b35', '#ffba08', '#ff006e'];
        ctx.globalAlpha = t.alpha * 0.7;
        ctx.fillStyle = colors[i % 3];
        ctx.beginPath();
        ctx.arc(t.x - i * 3, t.y + (Math.random() - 0.5) * 4, t.size * (1 - i / player.trail.length), 0, Math.PI * 2);
        ctx.fill();
        t.alpha -= 0.08;
    });
    ctx.globalAlpha = 1;

    // Rocket body
    ctx.fillStyle = '#e8e8e8';
    ctx.beginPath();
    ctx.moveTo(px + 28, py);
    ctx.lineTo(px - 16, py - 16);
    ctx.lineTo(px - 20, py);
    ctx.lineTo(px - 16, py + 16);
    ctx.closePath();
    ctx.fill();

    // Cockpit window
    ctx.fillStyle = '#4ae0ff';
    ctx.beginPath();
    ctx.arc(px + 8, py, 7, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#a8f0ff';
    ctx.beginPath();
    ctx.arc(px + 10, py - 2, 3, 0, Math.PI * 2);
    ctx.fill();

    // Top fin
    ctx.fillStyle = '#ff4757';
    ctx.beginPath();
    ctx.moveTo(px - 8, py - 14);
    ctx.lineTo(px - 18, py - 26);
    ctx.lineTo(px - 20, py - 10);
    ctx.closePath();
    ctx.fill();

    // Bottom fin
    ctx.fillStyle = '#ff4757';
    ctx.beginPath();
    ctx.moveTo(px - 8, py + 14);
    ctx.lineTo(px - 18, py + 26);
    ctx.lineTo(px - 20, py + 10);
    ctx.closePath();
    ctx.fill();

    // Shield effect
    if (shield) {
        ctx.strokeStyle = `rgba(74, 224, 255, ${0.4 + Math.sin(performance.now() / 150) * 0.3})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(px, py, 32, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
    }
}

// Draw a star bullet
function drawBullet(b) {
    ctx.fillStyle = '#ffe66d';
    ctx.shadowColor = '#ffe66d';
    ctx.shadowBlur = 8;
    // Star shape
    const spikes = 5;
    const outerR = 6;
    const innerR = 3;
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (i * Math.PI) / spikes - Math.PI / 2;
        const x = b.x + Math.cos(angle) * r;
        const y = b.y + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
}

// Enemy types
const ENEMY_TYPES = [
    { name: 'Asteroid', color: '#a0522d', size: 20, hp: 1, points: 10, draw: drawAsteroid },
    { name: 'UFO', color: '#7bed9f', size: 22, hp: 2, points: 25, draw: drawUFO },
    { name: 'Comet', color: '#ff6b81', size: 16, hp: 1, points: 15, draw: drawComet },
    { name: 'SpaceCrab', color: '#cf6a87', size: 24, hp: 3, points: 40, draw: drawSpaceCrab }
];

function drawAsteroid(e) {
    ctx.fillStyle = e.type.color;
    ctx.beginPath();
    const pts = 8;
    for (let i = 0; i < pts; i++) {
        const angle = (i / pts) * Math.PI * 2 + e.rotation;
        const wobble = e.wobbles[i] || 1;
        const r = e.type.size * wobble;
        const x = e.x + Math.cos(angle) * r;
        const y = e.y + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.lineWidth = 1;
}

function drawUFO(e) {
    const time = performance.now() / 500;
    // Dome
    ctx.fillStyle = '#a8e6cf';
    ctx.beginPath();
    ctx.arc(e.x, e.y - 6, 10, Math.PI, 0);
    ctx.fill();
    // Body
    ctx.fillStyle = e.type.color;
    ctx.beginPath();
    ctx.ellipse(e.x, e.y, e.type.size, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    // Lights
    for (let i = 0; i < 3; i++) {
        const lx = e.x - 12 + i * 12;
        const blink = Math.sin(time + i * 2) > 0;
        ctx.fillStyle = blink ? '#ffe66d' : '#ff6b81';
        ctx.beginPath();
        ctx.arc(lx, e.y + 2, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    // Beam (sometimes)
    if (Math.sin(time * 1.5) > 0.7) {
        ctx.fillStyle = 'rgba(126, 214, 223, 0.2)';
        ctx.beginPath();
        ctx.moveTo(e.x - 8, e.y + 8);
        ctx.lineTo(e.x + 8, e.y + 8);
        ctx.lineTo(e.x + 16, e.y + 40);
        ctx.lineTo(e.x - 16, e.y + 40);
        ctx.closePath();
        ctx.fill();
    }
}

function drawComet(e) {
    // Tail
    for (let i = 0; i < 6; i++) {
        ctx.globalAlpha = 0.5 - i * 0.08;
        ctx.fillStyle = '#ff9ff3';
        ctx.beginPath();
        ctx.arc(e.x + i * 8, e.y + Math.sin(e.wobbleAngle + i) * 3, e.type.size - i * 2, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    // Head
    ctx.fillStyle = e.type.color;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.type.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(e.x - 4, e.y - 4, 4, 0, Math.PI * 2);
    ctx.fill();
}

function drawSpaceCrab(e) {
    const bob = Math.sin(performance.now() / 300) * 3;
    // Body
    ctx.fillStyle = e.type.color;
    ctx.beginPath();
    ctx.ellipse(e.x, e.y + bob, e.type.size, e.type.size * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(e.x - 8, e.y - 10 + bob, 6, 0, Math.PI * 2);
    ctx.arc(e.x + 8, e.y - 10 + bob, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#2d3436';
    ctx.beginPath();
    ctx.arc(e.x - 8, e.y - 10 + bob, 3, 0, Math.PI * 2);
    ctx.arc(e.x + 8, e.y - 10 + bob, 3, 0, Math.PI * 2);
    ctx.fill();
    // Claws
    ctx.strokeStyle = e.type.color;
    ctx.lineWidth = 4;
    const clawOpen = Math.sin(performance.now() / 400) * 0.3;
    // Left claw
    ctx.beginPath();
    ctx.arc(e.x - 22, e.y + bob, 8, -0.5 + clawOpen, 1.5 - clawOpen);
    ctx.stroke();
    // Right claw
    ctx.beginPath();
    ctx.arc(e.x + 22, e.y + bob, 8, 1.6 + clawOpen, 3.6 - clawOpen);
    ctx.stroke();
    ctx.lineWidth = 1;
    // Legs
    ctx.strokeStyle = e.type.color;
    ctx.lineWidth = 2;
    for (let side = -1; side <= 1; side += 2) {
        for (let i = 0; i < 3; i++) {
            const legAngle = (i - 1) * 0.4 + Math.sin(performance.now() / 200 + i) * 0.2;
            ctx.beginPath();
            ctx.moveTo(e.x + side * 12, e.y + 8 + bob);
            ctx.lineTo(e.x + side * (20 + i * 4), e.y + 18 + bob + Math.sin(legAngle) * 4);
            ctx.stroke();
        }
    }
    ctx.lineWidth = 1;
}

// Power-up types
const POWERUP_TYPES = [
    { name: 'Shield', color: '#4ae0ff', symbol: 'S' },
    { name: 'RapidFire', color: '#ff6b35', symbol: 'R' },
    { name: 'ExtraLife', color: '#ff4757', symbol: '♥' },
    { name: 'ScoreBoost', color: '#ffe66d', symbol: '★' }
];

function drawPowerup(p) {
    const bob = Math.sin(performance.now() / 300 + p.y) * 4;
    // Glow
    ctx.shadowColor = p.type.color;
    ctx.shadowBlur = 15;
    // Capsule
    ctx.fillStyle = p.type.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y + bob, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Symbol
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.type.symbol, p.x, p.y + bob + 1);
}

// Spawn enemy
function spawnEnemy(now) {
    if (now - lastSpawn < SPAWN_INTERVAL_MS / difficultyMultiplier) return;
    lastSpawn = now;

    // Weighted selection based on difficulty
    let typeIndex = 0;
    const roll = Math.random();
    if (difficultyMultiplier > 1.8 && roll > 0.6) typeIndex = 3;
    else if (difficultyMultiplier > 1.3 && roll > 0.5) typeIndex = Math.random() > 0.5 ? 2 : 1;
    else if (roll > 0.7) typeIndex = 1;

    const type = ENEMY_TYPES[typeIndex];
    const enemy = {
        x: GAME_WIDTH + type.size,
        y: Math.random() * (GAME_HEIGHT - 80) + 40,
        type: type,
        hp: type.hp,
        speed: (ENEMY_BASE_SPEED + Math.random() * 0.8) * difficultyMultiplier,
        rotation: 0,
        wobbles: [],
        wobbleAngle: Math.random() * Math.PI * 2,
        sineOffset: Math.random() * Math.PI * 2
    };
    // Asteroid wobble vertices
    for (let i = 0; i < 8; i++) {
        enemy.wobbles.push(0.7 + Math.random() * 0.6);
    }
    enemies.push(enemy);
}

// Spawn power-up
function spawnPowerup(now) {
    if (now - lastPowerup < POWERUP_INTERVAL_MS) return;
    lastPowerup = now;
    const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    powerups.push({
        x: GAME_WIDTH + 20,
        y: Math.random() * (GAME_HEIGHT - 80) + 40,
        type: type
    });
}

// Particles
function spawnExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            color: color,
            size: Math.random() * 5 + 2
        });
    }
}

// Collision detection
function circleCollision(a, ar, b, br) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return dx * dx + dy * dy < (ar + br) * (ar + br);
}

// Update game
function update(now, dt) {
    gameTime += dt;
    difficultyMultiplier = 1 + gameTime / 60;

    // Player movement
    if (keys['ArrowUp'] || keys['KeyW']) player.y -= PLAYER_SPEED;
    if (keys['ArrowDown'] || keys['KeyS']) player.y += PLAYER_SPEED;
    if (keys['ArrowLeft'] || keys['KeyA']) player.x -= PLAYER_SPEED;
    if (keys['ArrowRight'] || keys['KeyD']) player.x += PLAYER_SPEED;
    player.x = Math.max(30, Math.min(GAME_WIDTH - 30, player.x));
    player.y = Math.max(24, Math.min(GAME_HEIGHT - 24, player.y));

    // Shooting
    const fireCooldown = rapidFire ? 100 : shotCooldown;
    if (keys['Space'] && now - lastShot > fireCooldown) {
        lastShot = now;
        bullets.push({ x: player.x + 28, y: player.y, speed: BULLET_SPEED });
    }

    // Bullets
    bullets.forEach(b => b.x += b.speed);
    bullets = bullets.filter(b => b.x < GAME_WIDTH + 10);

    // Enemies
    enemies.forEach(e => {
        e.x -= e.speed;
        e.rotation += 0.02;
        e.wobbleAngle += 0.03;
        // Sine movement for UFOs and comets
        if (e.type.name === 'UFO') {
            e.y += Math.sin(performance.now() / 500 + e.sineOffset) * 1.2;
        }
        if (e.type.name === 'Comet') {
            e.y += Math.sin(performance.now() / 300 + e.sineOffset) * 0.8;
        }
    });
    enemies = enemies.filter(e => e.x > -40);

    // Power-ups
    powerups.forEach(p => p.x -= POWERUP_SPEED);
    powerups = powerups.filter(p => p.x > -20);

    // Bullet-enemy collisions
    bullets.forEach(b => {
        enemies.forEach(e => {
            if (circleCollision(b, 5, e, e.type.size)) {
                e.hp--;
                b.x = GAME_WIDTH + 100; // mark for removal
                spawnExplosion(b.x, b.y, '#ffe66d', 4);
                if (e.hp <= 0) {
                    score += e.type.points;
                    spawnExplosion(e.x, e.y, e.type.color, 15);
                    e.x = -100; // mark for removal
                }
            }
        });
    });

    // Player-enemy collisions
    enemies.forEach(e => {
        if (circleCollision(player, 16, e, e.type.size)) {
            if (shield) {
                shield = false;
                spawnExplosion(e.x, e.y, '#4ae0ff', 20);
                e.x = -100;
            } else {
                lives--;
                spawnExplosion(player.x, player.y, '#ff4757', 20);
                e.x = -100;
                if (lives <= 0) {
                    gameState = STATE.GAMEOVER;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('spacefun_highscore', highScore);
                    }
                }
            }
        }
    });

    // Player-powerup collisions
    powerups.forEach(p => {
        if (circleCollision(player, 20, p, 14)) {
            spawnExplosion(p.x, p.y, p.type.color, 10);
            switch (p.type.name) {
                case 'Shield': shield = true; shieldTimer = 10; break;
                case 'RapidFire': rapidFire = true; rapidFireTimer = 5; break;
                case 'ExtraLife': lives = Math.min(lives + 1, 5); break;
                case 'ScoreBoost': score += 100; break;
            }
            p.x = -100; // mark for removal
        }
    });
    powerups = powerups.filter(p => p.x > -20);

    // Timers
    if (shield) {
        shieldTimer -= dt;
        if (shieldTimer <= 0) shield = false;
    }
    if (rapidFire) {
        rapidFireTimer -= dt;
        if (rapidFireTimer <= 0) rapidFire = false;
    }

    // Particles
    particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.size *= 0.97;
    });
    particles = particles.filter(p => p.life > 0);

    // Spawning
    spawnEnemy(now);
    spawnPowerup(now);
}

// Draw background
function drawBackground() {
    // Deep space gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
    gradient.addColorStop(0, '#0a0a2e');
    gradient.addColorStop(0.5, '#1a1a4e');
    gradient.addColorStop(1, '#0a0a2e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Stars
    stars.forEach(s => {
        s.x -= s.speed;
        s.twinkle += 0.03;
        if (s.x < 0) { s.x = GAME_WIDTH; s.y = Math.random() * GAME_HEIGHT; }
        const alpha = 0.5 + Math.sin(s.twinkle) * 0.3;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Distant nebula
    const nebulaX = (performance.now() / 80) % (GAME_WIDTH + 400) - 200;
    ctx.globalAlpha = 0.08;
    const nebGrad = ctx.createRadialGradient(GAME_WIDTH - nebulaX, 200, 10, GAME_WIDTH - nebulaX, 200, 200);
    nebGrad.addColorStop(0, '#9b59b6');
    nebGrad.addColorStop(0.5, '#3498db');
    nebGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = nebGrad;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    ctx.globalAlpha = 1;
}

// Draw HUD
function drawHUD() {
    // Score
    ctx.fillStyle = '#ffe66d';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 16, 32);

    // High score
    ctx.fillStyle = '#aaa';
    ctx.font = '14px Arial';
    ctx.fillText(`Best: ${highScore}`, 16, 52);

    // Lives
    for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#ff4757';
        ctx.font = '22px Arial';
        ctx.fillText('♥', GAME_WIDTH - 36 - i * 28, 32);
    }

    // Active power-ups
    let puY = 70;
    if (shield) {
        ctx.fillStyle = '#4ae0ff';
        ctx.font = '14px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(`Shield: ${Math.ceil(shieldTimer)}s`, GAME_WIDTH - 16, puY);
        puY += 20;
    }
    if (rapidFire) {
        ctx.fillStyle = '#ff6b35';
        ctx.font = '14px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(`Rapid Fire: ${Math.ceil(rapidFireTimer)}s`, GAME_WIDTH - 16, puY);
    }
    ctx.textAlign = 'left';
}

// Draw menu screen
function drawMenu() {
    drawBackground();

    // Title
    ctx.fillStyle = '#ffe66d';
    ctx.font = 'bold 52px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('SpaceFun', GAME_WIDTH / 2, 180);

    // Subtitle
    ctx.fillStyle = '#4ae0ff';
    ctx.font = '22px Arial';
    ctx.fillText('Kids Space Adventure!', GAME_WIDTH / 2, 220);

    // Animated rocket
    const rocketY = 300 + Math.sin(performance.now() / 500) * 15;
    ctx.save();
    ctx.translate(GAME_WIDTH / 2, rocketY);
    // Simple rocket
    ctx.fillStyle = '#e8e8e8';
    ctx.beginPath();
    ctx.moveTo(40, 0);
    ctx.lineTo(-20, -20);
    ctx.lineTo(-26, 0);
    ctx.lineTo(-20, 20);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#4ae0ff';
    ctx.beginPath();
    ctx.arc(12, 0, 9, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ff4757';
    ctx.beginPath();
    ctx.moveTo(-10, -18); ctx.lineTo(-24, -32); ctx.lineTo(-26, -12); ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-10, 18); ctx.lineTo(-24, 32); ctx.lineTo(-26, 12); ctx.closePath();
    ctx.fill();
    // Flame
    ctx.fillStyle = `hsl(${30 + Math.random() * 20}, 100%, 60%)`;
    ctx.beginPath();
    ctx.arc(-34, 0, 8 + Math.random() * 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Instructions
    ctx.fillStyle = '#fff';
    ctx.font = '18px Arial';
    ctx.fillText('Arrow Keys or WASD to move', GAME_WIDTH / 2, 420);
    ctx.fillText('SPACE to shoot', GAME_WIDTH / 2, 450);

    // Start prompt
    ctx.fillStyle = `rgba(255, 230, 109, ${0.5 + Math.sin(performance.now() / 400) * 0.5})`;
    ctx.font = 'bold 26px Arial';
    ctx.fillText('Press SPACE to Start!', GAME_WIDTH / 2, 520);

    ctx.textAlign = 'left';
}

// Draw game over screen
function drawGameOver() {
    drawBackground();

    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff4757';
    ctx.font = 'bold 48px Arial';
    ctx.fillText('Game Over!', GAME_WIDTH / 2, 200);

    ctx.fillStyle = '#ffe66d';
    ctx.font = 'bold 32px Arial';
    ctx.fillText(`Score: ${score}`, GAME_WIDTH / 2, 280);

    if (score >= highScore && score > 0) {
        ctx.fillStyle = '#7bed9f';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('New High Score!', GAME_WIDTH / 2, 330);
    }

    ctx.fillStyle = '#fff';
    ctx.font = '18px Arial';
    ctx.fillText(`Best: ${highScore}`, GAME_WIDTH / 2, 380);

    ctx.fillStyle = `rgba(255, 230, 109, ${0.5 + Math.sin(performance.now() / 400) * 0.5})`;
    ctx.font = 'bold 24px Arial';
    ctx.fillText('Press SPACE to Play Again!', GAME_WIDTH / 2, 460);

    ctx.textAlign = 'left';
}

// Main game loop
let lastTime = 0;
function gameLoop(timestamp) {
    const dt = lastTime ? (timestamp - lastTime) / 1000 : 0.016;
    lastTime = timestamp;

    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    switch (gameState) {
        case STATE.MENU:
            drawMenu();
            break;
        case STATE.PLAYING:
            update(timestamp, dt);
            drawBackground();
            powerups.forEach(p => drawPowerup(p));
            bullets.forEach(b => drawBullet(b));
            enemies.forEach(e => e.type.draw(e));
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            drawPlayer();
            drawHUD();
            break;
        case STATE.GAMEOVER:
            drawGameOver();
            break;
    }

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
